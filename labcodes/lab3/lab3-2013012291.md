# Lab 2

## Ex1

#### Map physical pages for virtural address.

1. Find the pte for the virtual address. If the pte does not exist, create one by setting the thrid parameter of *get_pte* to 1.
2. Check the return of system call *get_pte*. If it returns NULL, go to "failed".
3. Check the value of the returned page table entry.
    - If it is newly created, i.e. the value equals to 0. It means the page entry as well as the page does not exist previously, an initialization of the page is requested.
    - If it is not newly created, i.e. the value does not equal to 0. It means the page has been swapped out of the memory. Then it needs to be swapped back, which is the purpose of Ex2.
3. Assuming the page entry is newly created, alloc a page for the address using *pgdir_alloc_page*, the parameter "perm" is defined prior in thie function.
    1. *pgdir_alloc_page* will first alloc a page then initialize it according to its parameters.  
    2. First the page should be connected to the page table by *page_insert* in *pmm.c*. This will map the page and set the permission bits in page table entry.
    3. Then the page should be added to the list of swappable pages and record the virturl linear address in its pra_vaddr member variable, which is essential to the swap system.

#### Meanings of components in page table directory and page table entries.
- High 20 bits: the base address for next level of memory management module, which could be page table or page. These info are essensial for CPU to construct physical address from virtual address.
- Low 12 bits: flags recording properties of the entry, including whether it presents, is writable, is changed and so on. The definations are in mmu.h. With these flags, ucore and CPU would be able to:
    - manage page table and cache page entry more effectively.
        - 2 bits particularly useful for page replacement algorithm are "accessed bit" and "dirty bit". The spirit of clock like algorithms is to check these bits and find the page that is not used recently.
    - protect data from being accessed or written in a potentially hazardous manner.

#### If an exception happens while accessing a page, what would hardware do next?
1. Protect the context, such as values of %eip and %cs.
2. Pass the control to the kernel, which would carry out corresponding (page fault) ISR.
3. If the exception happends when carrying out ISR, goto **1.**. This might cause an infinite loop, until stack overflow.

## Ex2

#### Implementation of FIFO PRA.

- Three parts of the code need to be implemented. The first two parts are in *swap_fifo.c*. And the last part is in *vmm.c*.
- Code in *swap_fifo.c* concerns manipulation of linked list. The code will decide which page to be switched out when a page fault occurs, based on a FIFO PRA.
    - The list is used as queue and new element is added before the head (sentinel) while the oldest element is deleted right after the head.
    - *_fifo_swap_out_victim* effectively returns 2 values. The first reports the status of the function by direct "return". And the second is the address of the page to be swapped out by "*ptr_page = ...;". A pointer is used to pass more than 1 return value.
- Code in *vmm.c* concerns how to swap in the requested page stored in disks. 
    1. Check if the swap system is initialized properly.
    2. Swap in the page calling *swap_in*. The page allocated for the swapped page is returned using a pointer.
    2. The logic of the rest part of the code is the same with those in *pgdir_alloc_page*, so I simply copied that piece of code into this function.
        - The job *pgdir_alloc_page* does has already been analyzed in **Ex1 -> Map physical pages for virtual address. -> 3.**. 
        - The difference between code in *pgdir_allc_page* and my copy is that in *pgdir_alloc_page* the page is allocated by *pgdir_alloc_page* while in my code the page is swapped from disks.


1. If the secondary page table containing the pte requested is present, then it's easy. 
    - Find the base of the secondary page table using page index of the directory table, then add the offset (index of secondary page) to the base, according to corresponding la of the page entry.
    - A tricky point is that entries in page directory table record physical base addresses for secondary tables, while the function should return virtual address of the secondary table entry. 
    - So after getting the (physical) address of the page table entry required, it should be converted to virtual address.
2. Otherwise, which means the secondary page table containing the pte requested is not present, then it need to be created first.
    - If the caller of *get_pte* does not allow creating page table, or attempt to create page table using *alloc_page* failed, the only option is to return NULL; 
    - After the memory for the page table is allocated, it should be initialized by setting all bits of the page table to 0, indicating all entries are currently unavailable.
    - And the ref number of the page containing the page table should be set to 1, because the newly allocated page is refered and only refered by a page directory entry.
    - The corresponding page directory entry (32 bit) should record this new page table by:
        - Recording the address of the page table in high 20 bits. This is enough for recording because the address of the page table is 4K aligned, which means the low 12 bits of the address are always 0.
        - Recording the permission of the page table in low 12 bits.



#### Differences from the answer provided
The difference is really small. At the last line I used a numeric calculation to get the address while the anwser establish an array first. I think with the comment mine is more readable.

#### List of knowledge

1. The relation among pages, addresses of pages, virtual address and physical address
2. The meaning of *page_ref*.

## Ex3

#### Implementation of *page_remove_pte*.
1. Check the argument. 
2. Find the page by pte, then break the connection between them. 
    - The ref number of the page is decreased by 1. If the ref number of the pages reaches 0, the page should be released.
    - the pte is erased by setting all bits of the pte to 0.
3. Invalidate the TLB for the pte (for it does not exist anymore).

#### The relationship between page array and page directory/table entry.
1. If the entry is present, then it is related to an item in the page array.
2. Because the relation between page array index and physical address is linear, with physical address recorded in the page directory/table entry, page array index could be obtained, as well as the address of the page array item.

#### What would you do if you want physical address identical to virtual address?
1. Change the address of kernel in link file to 0x00100000.
2. Change the base of the kernel in memlayout.h to 0x00000000.
3. Delete redundant protection when enabling page.

#### Differences from the answer provided
Exactly the same.

#### List of knowledge
1. The same as Ex2.
2. Controll over TLB.
