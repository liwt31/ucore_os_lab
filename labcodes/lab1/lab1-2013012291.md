# Lab 1

## ex1
### List of knowledge and concept
to be completed

### How ucore.img is generated?

- Compile kernel and bootloader respectively.

    There are a lot of options for the GCC compiler, and the meanings can be found at the end of this ex.

    With those options, the components are compiled to be suitable for IA-32 platform, with GDB debugging infomation, and without unnecessary protections like the canary.

- Link the compiled components.

    By seperating compilation and linking when the source files are changed we don't have to remake the whole project.

    There are also many options for ld command, which also could be found at the end of the ex.

    The linking for the kernel uses a special script. The meaning of the script is detailed in the script file by comments. Frankly speaking I don't know much about the syntax of ld script. 

    The linking for the bootloader is simpler. The linker have to set 'start' in boot/bootasm. S as the entry of the program and its address have to be set to 0x7C00 for this is the address containing the 'second' instruction the CPU will carry out.

- Sign the bootblock.

    Sign the bootblock using sign generated from tools/sign.c.

    The effect is to set the last 2 bytes of the linked bootloader to be 'AA55'. This is necessary for a legal MBR.

- build the img.

    Build img by dd command. To mimic a harddisk create an empty file with 10000 sectors first.

    Then copy bootblock and kernel into the file subsequently.

### What consists of a legal MBR
- 446 Bytes of bootstrap code.
- 64 Bytes of partition info.
- 2 Bytes of signature.

### GCC options for compilation
- -I indicate the first dir in which to find headers.
- -fno-builtin do not use builtin functions (to prevent name collision).
- -Wall enable all warnings.
- -ggdb generate gdb debugging info.
- -m32 set target machine CPU as 32bit.
- -gstabs generate stabs debugging info.
- -nostdinc do not search header in standard dirs.
- -fno-stack-protector disable stack protector.
- -Os optimize as long as the size of the file does not increase.

### ld options (GNU linker)
- -m emulate the indicated linker.
- -nostdlib do not search lib in std. Only search those indicated in the command line.
- -T specify a script file to control the linking process.
- -o indicate linking object.
- -N set text and data section to be readable and writable.
- -e explicitly set the entry point of the program.
- -Ttext locate specified address.

## ex2
- Simply typing in 'make debug' under lab1/ dir does not give the desired starting address 0xFFF0. On the contrary, the starting address is 0x100000, the entrance of kernel rather than bootloader, which does not meet the requirement of the exercise.

- So, qemu and gdb must start manually and stop before bootloader is executed.

- To do this, first, start qemu using 'qemu-system-i386 -hda bin/ucore.img -parallel stdio -s -S'

    The meaning of parameters:<br>
    '-hda bin/ucore.img' means loading bin/ucore.img as the first hard drive.<br>
    'parallel stdio' means redirecting parallel communication to stdio.<br>
    '-s -S' makes qemu stop at the first instruction and wait for gdb command.
    
    Qemu will start in a different window and it's completely blank.

- Then, start gdb at a different terminal using 'gdb obj/bootblock.o'. The parameter helps gdb to find symbol for the bootloader.
- In the gdb interface, establish remote debugging by 'target remote localhost:1234'.

    The connection is successfully established when 'Remote debugging using localhost:1234' shows. Current address is 0xFFF0, but gdb can not resolve this. Indeed, The command is in BIOS and I don't know how to show it in gdb.

- Add a break point at 0x7C00 using 'b * 0x7C00'. Then test it.

    'Breakpoint 1 at 0x7c00: file boot/bootasm.S, line 16.' shows, the break point is set successfully.

    Typing 'c' to let the paused program continue. The program will stop at Breakpoint 1, the 16th line of boot/bootasm.S. The command is cli which is to disable interrupts. This is indeed the first instruction of the bootloader. The break point setting is successful.

    Some messages about the basic info of the system is shown in qemu window. It's probably generated by BIOS.

- single-step tracking of the code using 'step' and check the differences.

    Typing 'layout asm' and gdb will display all asm instruction of the program. 

    Bootblock.asm, bootasm.S and the disassembly provided by gdb are all slightly different from each other. A major difference is the format of instructions and registers. For example, in bootasm.S, all instuctions are carried out at word level and registers are 16 bits, while in bootblock.asm generated by disassembler, the suffixes of instructions are neglected and the prefixes of the registers are also strange. 

    In most cases, those difference do not matter. What interests me most is 3 cases of %al, (%bx, %si) in the disassembly by gdb at protcseg+17, +22 and +27 respectively. I don't know what's their meaning yet.

- Add customized break point and test it.

    Tried to add a break point at the entrace of a function. Typing in 'break bootmain' and then 'c', The program stopped at 0x7D1E the entrace of bootmain function.




