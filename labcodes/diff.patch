diff -Nur ../../OSbak/labcodes/lab7/.badarg.log lab7/.badarg.log
--- ../../OSbak/labcodes/lab7/.badarg.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.badarg.log	2017-05-13 08:55:41.368047638 +0800
@@ -0,0 +1,309 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "badarg".
+fork ok.
+badarg pass.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.badsegment.log lab7/.badsegment.log
--- ../../OSbak/labcodes/lab7/.badsegment.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.badsegment.log	2017-05-13 08:55:18.800055355 +0800
@@ -0,0 +1,328 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "badsegment".
+trapframe at 0xc03affb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc03affd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0x00000028
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000d General Protection
+  err  0x00000028
+  eip  0x00800f68
+  cs   0x----001b
+  flag 0x00003286 PF,SF,IF,IOPL=3
+  esp  0xafffffa0
+  ss   0x----0023
+unhandled trap.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/boot/bootasm.S lab7/boot/bootasm.S
--- ../../OSbak/labcodes/lab7/boot/bootasm.S	2017-02-26 17:12:48.623510657 +0800
+++ lab7/boot/bootasm.S	2017-05-08 18:47:26.806399682 +0800
@@ -26,7 +26,8 @@
     # Enable A20:
     #  For backwards compatibility with the earliest PCs, physical
     #  address line 20 is tied low, so that addresses higher than
-    #  1MB wrap around to zero by default. This code undoes this.
+    #  1MB wrap around to zero by default. This code undoes this
+    #  No need to pay much attention to this code. Take it as a necessary preparation to enable protection mode.
 seta20.1:
     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     testb $0x2, %al
@@ -66,7 +67,9 @@
     # and segment translation that makes virtual addresses
     # identical to physical addresses, so that the
     # effective memory map does not change during the switch.
+    # GDT: global descriptor table.
     lgdt gdtdesc
+	# load gdt, real mode instr
     movl %cr0, %eax
     orl $CR0_PE_ON, %eax
     movl %eax, %cr0
@@ -98,10 +101,16 @@
 # Bootstrap GDT
 .p2align 2                                          # force 4 byte alignment
 gdt:
+	# Fisrt seg descriptor, left blank is requested.
     SEG_NULLASM                                     # null seg
+	# Next 2 segs are for code and data repectively
+	# The first num parameter is the starting address, and the second is the length
+	# they actually overlap and have maximum space
+	# This is for the convenience of education. The protection is weak this way.
     SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
     SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
 
+# Description of gdt
 gdtdesc:
     .word 0x17                                      # sizeof(gdt) - 1
     .long gdt                                       # address gdt
diff -Nur ../../OSbak/labcodes/lab7/boot/bootmain.c lab7/boot/bootmain.c
--- ../../OSbak/labcodes/lab7/boot/bootmain.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/boot/bootmain.c	2017-05-08 18:47:26.806399682 +0800
@@ -37,6 +37,7 @@
 static void
 waitdisk(void) {
     while ((inb(0x1F7) & 0xC0) != 0x40)
+	// inb : assembly language, read(in) a byte(b) from a certain port
         /* do nothing */;
 }
 
@@ -47,10 +48,12 @@
     waitdisk();
 
     outb(0x1F2, 1);                         // count = 1
+	// num of sector to read
     outb(0x1F3, secno & 0xFF);
     outb(0x1F4, (secno >> 8) & 0xFF);
     outb(0x1F5, (secno >> 16) & 0xFF);
     outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+	// 1F3 to 1F6, address of LBA
     outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors
 
     // wait for disk to be ready
@@ -58,6 +61,7 @@
 
     // read a sector
     insl(0x1F0, dst, SECTSIZE / 4);
+	// import double word string from port
 }
 
 /* *
@@ -66,7 +70,8 @@
  * */
 static void
 readseg(uintptr_t va, uint32_t count, uint32_t offset) {
-    uintptr_t end_va = va + count;
+    intptr_t end_va = va + count;
+	// intptr_t : simply another name for int32_t. Why not uint32_t ?
 
     // round down to sector boundary
     va -= offset % SECTSIZE;
@@ -87,9 +92,11 @@
 bootmain(void) {
     // read the 1st page off disk
     readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+	// uintptr_t uint_32.
 
     // is this a valid ELF?
     if (ELFHDR->e_magic != ELF_MAGIC) {
+	// if the reading process goes wrong, the e_magic will not be initialized properly.
         goto bad;
     }
 
diff -Nur ../../OSbak/labcodes/lab7/.check_pmm.log lab7/.check_pmm.log
--- ../../OSbak/labcodes/lab7/.check_pmm.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.check_pmm.log	2017-05-08 18:47:26.806399682 +0800
@@ -0,0 +1,57 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc0105be6 (phys)
+  edata  0xc0117a36 (phys)
+  end    0xc0118968 (phys)
+Kernel executable memory footprint: 99KB
+ebp:0xc0116f48 eip:0xc0100a64 args:0x00010094 0x00010094 0xc0116f78 0xc01000ae 
+    kern/debug/kdebug.c:309: print_stackframe+21
+ebp:0xc0116f58 eip:0xc0100d75 args:0x00000000 0x00000000 0x00000000 0xc0116fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0116f78 eip:0xc01000ae args:0x00000000 0xc0116fa0 0xffff0000 0xc0116fa4 
+    kern/init/init.c:49: grade_backtrace2+19
+ebp:0xc0116f98 eip:0xc01000d0 args:0x00000000 0xffff0000 0xc0116fc4 0x00000029 
+    kern/init/init.c:54: grade_backtrace1+27
+ebp:0xc0116fb8 eip:0xc01000ed args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:59: grade_backtrace0+19
+ebp:0xc0116fd8 eip:0xc010010e args:0x00000000 0x00000000 0x00000000 0xc0105c00 
+    kern/init/init.c:64: grade_backtrace+26
+ebp:0xc0116ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:29: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+c01b9000
+check_pgdir() succeeded!
+0
+1ba007
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+++ setup timer interrupts
+0: @ring 0
+0:  cs = 8
+0:  ds = 10
+0:  es = 10
+0:  ss = 10
++++ switch to  user  mode +++
+100 ticks
+End of Test.
+kernel panic at kern/trap/trap.c:18:
+    EOT: kernel seems ok.
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.check_swap.log lab7/.check_swap.log
--- ../../OSbak/labcodes/lab7/.check_swap.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.check_swap.log	2017-05-08 18:47:26.806399682 +0800
@@ -0,0 +1,98 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc0108565 (phys)
+  edata  0xc0120a60 (phys)
+  end    0xc0121b5c (phys)
+Kernel executable memory footprint: 135KB
+ebp:0xc011ff48 eip:0xc0100a6e args:0x00010094 0x00010094 0xc011ff78 0xc01000b8 
+    kern/debug/kdebug.c:309: print_stackframe+21
+ebp:0xc011ff58 eip:0xc0100d7f args:0x00000000 0x00000000 0x00000000 0xc011ffc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc011ff78 eip:0xc01000b8 args:0x00000000 0xc011ffa0 0xffff0000 0xc011ffa4 
+    kern/init/init.c:58: grade_backtrace2+19
+ebp:0xc011ff98 eip:0xc01000da args:0x00000000 0xffff0000 0xc011ffc4 0x0000002a 
+    kern/init/init.c:63: grade_backtrace1+27
+ebp:0xc011ffb8 eip:0xc01000f7 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:68: grade_backtrace0+19
+ebp:0xc011ffd8 eip:0xc0100118 args:0x00000000 0x00000000 0x00000000 0xc0108580 
+    kern/init/init.c:73: grade_backtrace+26
+ebp:0xc011fff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:32: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31965
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 7
+check_swap() succeeded!
+++ setup timer interrupts
+100 ticks
+End of Test.
+kernel panic at kern/trap/trap.c:20:
+    EOT: kernel seems ok.
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.check_vmm.log lab7/.check_vmm.log
--- ../../OSbak/labcodes/lab7/.check_vmm.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.check_vmm.log	2017-05-08 18:47:26.806399682 +0800
@@ -0,0 +1,102 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010964b (phys)
+  edata  0xc0124a88 (phys)
+  end    0xc0127c04 (phys)
+Kernel executable memory footprint: 159KB
+ebp:0xc0123f48 eip:0xc0100a76 args:0x00010094 0x00010094 0xc0123f78 0xc01000c0 
+    kern/debug/kdebug.c:309: print_stackframe+21
+ebp:0xc0123f58 eip:0xc0100d87 args:0x00000000 0x00000000 0x00000000 0xc0123fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0123f78 eip:0xc01000c0 args:0x00000000 0xc0123fa0 0xffff0000 0xc0123fa4 
+    kern/init/init.c:58: grade_backtrace2+19
+ebp:0xc0123f98 eip:0xc01000e2 args:0x00000000 0xffff0000 0xc0123fc4 0x0000002a 
+    kern/init/init.c:63: grade_backtrace1+27
+ebp:0xc0123fb8 eip:0xc01000ff args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:68: grade_backtrace0+19
+ebp:0xc0123fd8 eip:0xc0100120 args:0x00000000 0x00000000 0x00000000 0xc0109660 
+    kern/init/init.c:73: grade_backtrace+26
+ebp:0xc0123ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31956
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+this initproc, pid = 1, name = "init"
+To U: "Hello world!!".
+To U: "en.., Bye, Bye. :)"
+kernel panic at kern/process/proc.c:343:
+    process exit!!.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.divzero.log lab7/.divzero.log
--- ../../OSbak/labcodes/lab7/.divzero.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.divzero.log	2017-05-13 08:55:21.824054328 +0800
@@ -0,0 +1,328 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "divzero".
+trapframe at 0xc03affb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc03affd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0x00000000
+  eax  0x00000001
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x00000000 Divide error
+  err  0x00000000
+  eip  0x00800f70
+  cs   0x----001b
+  flag 0x00003286 PF,SF,IF,IOPL=3
+  esp  0xafffffa0
+  ss   0x----0023
+unhandled trap.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.exit.log lab7/.exit.log
--- ../../OSbak/labcodes/lab7/.exit.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.exit.log	2017-05-13 08:55:44.392046591 +0800
@@ -0,0 +1,313 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "exit".
+I am the parent. Forking the child...
+I am parent, fork a child pid 13
+I am the parent, waiting now..
+I am the child.
+waitpid 13 ok.
+exit pass.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.faultreadkernel.log lab7/.faultreadkernel.log
--- ../../OSbak/labcodes/lab7/.faultreadkernel.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.faultreadkernel.log	2017-05-13 08:55:27.764052307 +0800
@@ -0,0 +1,143 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "faultreadkernel".
+not valid addr fac00000, and  can not find it in vma
+trapframe at 0xc03affb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc03affd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0xfac00000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000005
+  eip  0x00800f69
+  cs   0x----001b
+  flag 0x00003286 PF,SF,IF,IOPL=3
+  esp  0xafffffa0
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:212:
+    handle user mode pgfault failed. ret=-3
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.faultread.log lab7/.faultread.log
--- ../../OSbak/labcodes/lab7/.faultread.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.faultread.log	2017-05-13 08:55:26.336052794 +0800
@@ -0,0 +1,143 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "faultread".
+not valid addr 0, and  can not find it in vma
+trapframe at 0xc03affb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc03affd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0x00000000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000004
+  eip  0x00800f69
+  cs   0x----001b
+  flag 0x00003286 PF,SF,IF,IOPL=3
+  esp  0xafffffa0
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:212:
+    handle user mode pgfault failed. ret=-3
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.forktest.log lab7/.forktest.log
--- ../../OSbak/labcodes/lab7/.forktest.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.forktest.log	2017-05-13 08:55:53.512043428 +0800
@@ -0,0 +1,340 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "forktest".
+I am child 31
+I am child 30
+I am child 29
+I am child 28
+I am child 27
+I am child 26
+I am child 25
+I am child 24
+I am child 23
+I am child 22
+I am child 21
+I am child 20
+I am child 19
+I am child 18
+I am child 17
+I am child 16
+I am child 15
+I am child 14
+I am child 13
+I am child 12
+I am child 11
+I am child 10
+I am child 9
+I am child 8
+I am child 7
+I am child 6
+I am child 5
+I am child 4
+I am child 3
+I am child 2
+I am child 1
+I am child 0
+forktest pass.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.forktree.log lab7/.forktree.log
--- ../../OSbak/labcodes/lab7/.forktree.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.forktree.log	2017-05-13 08:55:56.540042371 +0800
@@ -0,0 +1,338 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "forktree".
+0002: I am ''
+000e: I am '1'
+0010: I am '11'
+0012: I am '111'
+0014: I am '1111'
+0013: I am '1110'
+0011: I am '110'
+0016: I am '1101'
+0015: I am '1100'
+000f: I am '10'
+0018: I am '101'
+001a: I am '1011'
+0019: I am '1010'
+0017: I am '100'
+001c: I am '1001'
+001b: I am '1000'
+000d: I am '0'
+001e: I am '01'
+0020: I am '011'
+0022: I am '0111'
+0021: I am '0110'
+001f: I am '010'
+0024: I am '0101'
+0023: I am '0100'
+001d: I am '00'
+0026: I am '001'
+0028: I am '0011'
+0027: I am '0010'
+0025: I am '000'
+002a: I am '0001'
+0029: I am '0000'
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is eating
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_sema is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_sema is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+No.4 philosopher_condvar quit
+No.1 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.hello.log lab7/.hello.log
--- ../../OSbak/labcodes/lab7/.hello.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.hello.log	2017-05-13 08:55:30.800051270 +0800
@@ -0,0 +1,310 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "hello".
+Hello world!!.
+I am process 2.
+hello pass.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/kern/debug/kdebug.c lab7/kern/debug/kdebug.c
--- ../../OSbak/labcodes/lab7/kern/debug/kdebug.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/debug/kdebug.c	2017-05-08 18:47:26.806399682 +0800
@@ -335,7 +335,7 @@
  * */
 void
 print_stackframe(void) {
-     /* LAB1 YOUR CODE : STEP 1 */
+     /* LAB1 2013012291 : STEP 1 */
      /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
       * (2) call read_eip() to get the value of eip. the type is (uint32_t);
       * (3) from 0 .. STACKFRAME_DEPTH
@@ -347,5 +347,21 @@
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
+    uint32_t ebp = read_ebp();
+    uint32_t eip = read_eip();
+    int i;
+    for(i=0;i<STACKFRAME_DEPTH;i++){
+        if(0 == ebp) break;
+        cprintf("ebp:0x%08x eip:0x%08x ", ebp, eip);
+        cprintf("args:");
+        int j;
+        for(j=0;j<4;j++){
+            cprintf("0x%08x ",*((uint32_t*)ebp+2+j));
+        }
+        cprintf("\n");
+        print_debuginfo(eip-1);
+        eip = *((uint32_t*)ebp + 1);
+        ebp = *((uint32_t*)ebp);
+    }
 }
 
diff -Nur ../../OSbak/labcodes/lab7/kern/init/init.c lab7/kern/init/init.c
--- ../../OSbak/labcodes/lab7/kern/init/init.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/init/init.c	2017-05-08 18:47:26.806399682 +0800
@@ -95,11 +95,28 @@
 static void
 lab1_switch_to_user(void) {
     //LAB1 CHALLENGE 1 : TODO
+    // Make room for esp and ss
+    asm volatile ( "subl $8, %%esp \n"
+            "int %0 \n"
+    // restore esp from pushl ebp;movl esp,ebp
+            "movl %%ebp, %%esp"
+             : 
+             : "i" (T_SWITCH_TOU));
 }
 
 static void
 lab1_switch_to_kernel(void) {
     //LAB1 CHALLENGE 1 :  TODO
+    // It is commented in trapframe that the last 2 bytes of struct trapframe
+    // is reserved for crossing rings. As far as I am concerned, switching from
+    // user to kernel is crossing ring. So I left 2 bytes here just in case. If 
+    // it's not necessary it doesn't matter, because in the end it's what's 
+    // stores in %ebp that determines the value of %esp
+    asm volatile ( "subl $8, %%esp \n"
+            "int %0 \n"
+            "movl %%ebp, %%esp"
+             : 
+             : "i" (T_SWITCH_TOK));
 }
 
 static void
diff -Nur ../../OSbak/labcodes/lab7/kern/mm/default_pmm.c lab7/kern/mm/default_pmm.c
--- ../../OSbak/labcodes/lab7/kern/mm/default_pmm.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/mm/default_pmm.c	2017-05-08 18:47:26.810399732 +0800
@@ -9,7 +9,7 @@
    usually split, and the remainder added to the list as another free block.
    Please see Page 196~198, Section 8.2 of Yan Wei Min's chinese book "Data Structure -- C programming language"
 */
-// LAB2 EXERCISE 1: YOUR CODE
+// LAB2 EXERCISE 1: 2013012291
 // you should rewrite functions: default_init,default_init_memmap,default_alloc_pages, default_free_pages.
 /*
  * Details of FFMA
@@ -72,10 +72,10 @@
     for (; p != base + n; p ++) {
         assert(PageReserved(p));
         p->flags = p->property = 0;
+        SetPageProperty(p);
         set_page_ref(p, 0);
     }
     base->property = n;
-    SetPageProperty(base);
     nr_free += n;
     list_add(&free_list, &(base->page_link));
 }
@@ -97,13 +97,17 @@
     }
     if (page != NULL) {
         list_del(&(page->page_link));
-        if (page->property > n) {
+        if (page->property > n) { // If the block is not malloced completely, 
+                                    // create a new block
             struct Page *p = page + n;
             p->property = page->property - n;
             list_add(&free_list, &(p->page_link));
-    }
+        }
+        struct Page *p = page;
+        for(; p != page + n; p ++){
+            ClearPageProperty(p);
+        }
         nr_free -= n;
-        ClearPageProperty(page);
     }
     return page;
 }
@@ -115,28 +119,28 @@
     for (; p != base + n; p ++) {
         assert(!PageReserved(p) && !PageProperty(p));
         p->flags = 0;
+        SetPageProperty(p);
         set_page_ref(p, 0);
     }
     base->property = n;
-    SetPageProperty(base);
     list_entry_t *le = list_next(&free_list);
     while (le != &free_list) {
         p = le2page(le, page_link);
         le = list_next(le);
         if (base + base->property == p) {
             base->property += p->property;
-            ClearPageProperty(p);
+			p->property = 0;
             list_del(&(p->page_link));
         }
         else if (p + p->property == base) {
             p->property += base->property;
-            ClearPageProperty(base);
+			base->property = 0;
             base = p;
             list_del(&(p->page_link));
         }
     }
     nr_free += n;
-    list_add(&free_list, &(base->page_link));
+    list_add_before(&free_list, &(base->page_link));
 }
 
 static size_t
diff -Nur ../../OSbak/labcodes/lab7/kern/mm/memlayout.h lab7/kern/mm/memlayout.h
--- ../../OSbak/labcodes/lab7/kern/mm/memlayout.h	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/mm/memlayout.h	2017-05-08 18:47:26.810399732 +0800
@@ -152,7 +152,7 @@
 
 /* free_area_t - maintains a doubly linked list to record free (unused) pages */
 typedef struct {
-    list_entry_t free_list;         // the list header
+    list_entry_t free_list;         // the list header, actually acts as a sentinel
     unsigned int nr_free;           // # of free pages in this free list
 } free_area_t;
 
diff -Nur ../../OSbak/labcodes/lab7/kern/mm/pmm.c lab7/kern/mm/pmm.c
--- ../../OSbak/labcodes/lab7/kern/mm/pmm.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/mm/pmm.c	2017-05-08 18:47:26.810399732 +0800
@@ -363,7 +363,7 @@
 // return vaule: the kernel virtual address of this pte
 pte_t *
 get_pte(pde_t *pgdir, uintptr_t la, bool create) {
-    /* LAB2 EXERCISE 2: YOUR CODE
+    /* LAB2 EXERCISE 2: 2013012291
      *
      * If you need to visit a physical address, please use KADDR()
      * please read pmm.h for useful macros
@@ -396,6 +396,21 @@
     }
     return NULL;          // (8) return page table entry
 #endif
+    pde_t *pdep = pgdir + PDX(la);
+    if (!(*pdep & PTE_P)){
+        if (!create){
+            return NULL;
+        }
+        struct Page *page_p = alloc_page();
+        if (!page_p){
+            return NULL;
+        }
+        set_page_ref(page_p, 1);
+        uintptr_t ptp = page2pa(page_p);
+        memset(KADDR(ptp), 0, PGSIZE);
+        *pdep = (uint32_t)ptp + PTE_USER;
+    }
+    return KADDR(PDE_ADDR(*pdep) + 4 * PTX(la)); // use a constant to mimic pointer operation
 }
 
 //get_page - get related Page struct for linear address la using PDT pgdir
@@ -416,7 +431,7 @@
 //note: PT is changed, so the TLB need to be invalidate 
 static inline void
 page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
-    /* LAB2 EXERCISE 3: YOUR CODE
+    /* LAB2 EXERCISE 3: 2013012291
      *
      * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
      *
@@ -441,6 +456,14 @@
                                   //(6) flush tlb
     }
 #endif
+    if (*ptep & PTE_P){
+        struct Page *page_p = pte2page(*ptep);
+        if (page_ref_dec(page_p) == 0){
+            free_page(page_p);
+        }
+        *ptep = 0;
+        tlb_invalidate(pgdir, la);
+    }
 }
 
 void
@@ -500,29 +523,31 @@
             if ((nptep = get_pte(to, start, 1)) == NULL) {
                 return -E_NO_MEM;
             }
-        uint32_t perm = (*ptep & PTE_USER);
-        //get page from ptep
-        struct Page *page = pte2page(*ptep);
-        // alloc a page for process B
-        struct Page *npage=alloc_page();
-        assert(page!=NULL);
-        assert(npage!=NULL);
-        int ret=0;
-        /* LAB5:EXERCISE2 YOUR CODE
-         * replicate content of page to npage, build the map of phy addr of nage with the linear addr start
-         *
-         * Some Useful MACROs and DEFINEs, you can use them in below implementation.
-         * MACROs or Functions:
-         *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.h)
-         *    page_insert: build the map of phy addr of an Page with the linear addr la
-         *    memcpy: typical memory copy function
-         *
-         * (1) find src_kvaddr: the kernel virtual address of page
-         * (2) find dst_kvaddr: the kernel virtual address of npage
-         * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
-         * (4) build the map of phy addr of  nage with the linear addr start
-         */
-        assert(ret == 0);
+			uint32_t perm = (*ptep & PTE_USER);
+			//get page from ptep
+			struct Page *page = pte2page(*ptep);
+			// alloc a page for process B
+			struct Page *npage=alloc_page();
+			assert(page!=NULL);
+			assert(npage!=NULL);
+			int ret=0;
+			/* LAB5:EXERCISE2 2013012291
+			 * replicate content of page to npage, build the map of phy addr of nage with the linear addr start
+			 *
+			 * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+			 * MACROs or Functions:
+			 *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.h)
+			 *    page_insert: build the map of phy addr of an Page with the linear addr la
+			 *    memcpy: typical memory copy function
+			 *
+			 * (1) find src_kvaddr: the kernel virtual address of page
+			 * (2) find dst_kvaddr: the kernel virtual address of npage
+			 * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
+			 * (4) build the map of phy addr of  nage with the linear addr start
+			 */
+			memcpy(page2kva(npage), page2kva(page), PGSIZE);
+			page_insert(to, npage, start, perm);
+			assert(ret == 0);
         }
         start += PGSIZE;
     } while (start != 0 && start < end);
diff -Nur ../../OSbak/labcodes/lab7/kern/mm/swap.c lab7/kern/mm/swap.c
--- ../../OSbak/labcodes/lab7/kern/mm/swap.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/mm/swap.c	2017-05-08 18:47:26.810399732 +0800
@@ -125,7 +125,7 @@
      assert(result!=NULL);
 
      pte_t *ptep = get_pte(mm->pgdir, addr, 0);
-     // cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
+     //cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
     
      int r;
      if ((r = swapfs_read((*ptep), result)) != 0)
diff -Nur ../../OSbak/labcodes/lab7/kern/mm/swap_fifo.c lab7/kern/mm/swap_fifo.c
--- ../../OSbak/labcodes/lab7/kern/mm/swap_fifo.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/mm/swap_fifo.c	2017-05-08 18:47:26.810399732 +0800
@@ -38,6 +38,21 @@
      //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
      return 0;
 }
+static void
+print_list(list_entry_t * head){
+    if ( head == NULL){
+        extern struct mm_struct *check_mm_struct;
+        head=(list_entry_t*) check_mm_struct->sm_priv;
+    }
+    cprintf("head---> %x\n", head);
+    cprintf("head->prev---> %x\n", head->prev);
+    list_entry_t *cur = head->next;
+    while(cur != head){
+        struct Page * page = le2page(cur, pra_page_link);
+        cprintf("%x - %x - %x\n", cur, page, page->pra_vaddr);
+        cur = cur->next;
+    }
+}
 /*
  * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
  */
@@ -49,8 +64,9 @@
  
     assert(entry != NULL && head != NULL);
     //record the page access situlation
-    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    /*LAB3 EXERCISE 2: 2013012291*/ 
     //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+    list_add_before(head, entry);
     return 0;
 }
 /*
@@ -64,17 +80,31 @@
          assert(head != NULL);
      assert(in_tick==0);
      /* Select the victim */
-     /*LAB3 EXERCISE 2: YOUR CODE*/ 
+     /*LAB3 EXERCISE 2: 2013012291*/ 
      //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
      //(2)  set the addr of addr of this page to ptr_page
+     *ptr_page = le2page(head->next, pra_page_link);
+     list_del(head->next);
      return 0;
 }
 
+
+static void
+diag(int avoid){
+    print_list(NULL);
+    int i;
+    for (i = 0; i < 5 ; i++){
+        if (i == avoid) continue;
+        cprintf("%x, ", *(unsigned char *)((1 + i) * 0x1000));
+    }
+}
+
 static int
 _fifo_check_swap(void) {
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num==4);
+    assert(check_mm_struct != NULL);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num==4);
@@ -84,29 +114,38 @@
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num==4);
+    //diag(5);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num==5);
+   // diag(0);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num==5);
+    //diag(0);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num==6);
+    //diag(1);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num==7);
+    //diag(2);
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num==8);
+    //diag(3);
     cprintf("write Virt Page d in fifo_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
     assert(pgfault_num==9);
+    //diag(4);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num==10);
+    //diag(1);
     cprintf("write Virt Page a in fifo_check_swap\n");
     assert(*(unsigned char *)0x1000 == 0x0a);
+    //diag(1);
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num==11);
     return 0;
diff -Nur ../../OSbak/labcodes/lab7/kern/mm/vmm.c lab7/kern/mm/vmm.c
--- ../../OSbak/labcodes/lab7/kern/mm/vmm.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/mm/vmm.c	2017-05-08 18:47:26.810399732 +0800
@@ -433,8 +433,7 @@
 
     ret = -E_NO_MEM;
 
-    pte_t *ptep=NULL;
-    /*LAB3 EXERCISE 1: YOUR CODE
+    /*LAB3 EXERCISE 1: 2013012291
     * Maybe you want help comment, BELOW comments can help you finish the code
     *
     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
@@ -451,15 +450,20 @@
     *   mm->pgdir : the PDT of these vma
     *
     */
-#if 0
-    /*LAB3 EXERCISE 1: YOUR CODE*/
-    ptep = ???              //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+    /*LAB3 EXERCISE 1: 2013012291*/
+    pte_t *ptep = get_pte(mm->pgdir, addr, 1);              //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+    if (ptep == NULL){
+        cprintf("Get pte for addr 0x%08x failed.\n", addr);
+        goto failed;
+    }
     if (*ptep == 0) {
-                            //(2) if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr
-
+        if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL){
+            cprintf("Alloc page for 0x%08x failed.\n", addr);
+            goto failed;
+        }
     }
     else {
-    /*LAB3 EXERCISE 2: YOUR CODE
+    /*LAB3 EXERCISE 2: 2013012291
     * Now we think this pte is a  swap entry, we should load data from disk to a page with phy addr,
     * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page.
     *
@@ -486,13 +490,22 @@
                                     //(2) According to the mm, addr AND page, setup the map of phy addr <---> logical addr
                                     //(3) make the page swappable.
                                     //(4) [NOTICE]: you myabe need to update your lab3's implementation for LAB5's normal execution.
+            swap_in(mm, addr, &page);
+            if (page != NULL) {
+                if (page_insert(mm->pgdir, page, addr, perm) != 0) {
+                    free_page(page);
+                    cprintf("insert page 0x%08x to pte failed.\n");
+                    goto failed;
+                }
+                swap_map_swappable(mm, addr, page, 0);
+                page->pra_vaddr = addr;
+            }
         }
         else {
             cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
             goto failed;
         }
    }
-#endif
    ret = 0;
 failed:
     return ret;
diff -Nur ../../OSbak/labcodes/lab7/kern/process/proc.c lab7/kern/process/proc.c
--- ../../OSbak/labcodes/lab7/kern/process/proc.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/process/proc.c	2017-05-13 08:56:26.480031797 +0800
@@ -87,7 +87,7 @@
 alloc_proc(void) {
     struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
     if (proc != NULL) {
-    //LAB4:EXERCISE1 YOUR CODE
+    //LAB4:EXERCISE1 2013012291
     /*
      * below fields in proc_struct need to be initialized
      *       enum proc_state state;                      // Process state
@@ -103,13 +103,19 @@
      *       uint32_t flags;                             // Process flag
      *       char name[PROC_NAME_LEN + 1];               // Process name
      */
-     //LAB5 YOUR CODE : (update LAB4 steps)
+     //LAB5 2013012291 : (update LAB4 steps)
     /*
      * below fields(add in LAB5) in proc_struct need to be initialized	
      *       uint32_t wait_state;                        // waiting state
      *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes
 	 */
-     //LAB6 YOUR CODE : (update LAB5 steps)
+        memset(proc, 0, sizeof(struct proc_struct));
+        //might not be necessary because PROC_UNINIT = 0
+        //proc->state = PROC_UNINIT; 
+        proc->pid = -1;
+        extern uintptr_t boot_cr3;
+        proc->cr3 = boot_cr3;
+     //LAB6 2013012291 : (update LAB5 steps)
     /*
      * below fields(add in LAB6) in proc_struct need to be initialized
      *     struct run_queue *rq;                       // running queue contains Process
@@ -119,6 +125,9 @@
      *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process
      *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
      */
+		proc->time_slice = MAX_TIME_SLICE;
+		list_init(&proc->run_link);
+		proc->lab6_priority = 1;
     }
     return proc;
 }
@@ -380,7 +389,7 @@
         goto fork_out;
     }
     ret = -E_NO_MEM;
-    //LAB4:EXERCISE2 YOUR CODE
+    //LAB4:EXERCISE2 2013012291
     /*
      * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
      * MACROs or Functions:
@@ -406,13 +415,35 @@
     //    6. call wakeup_proc to make the new child process RUNNABLE
     //    7. set ret vaule using child proc's pid
 
-	//LAB5 YOUR CODE : (update LAB4 steps)
+	//LAB5 2013012291 : (update LAB4 steps)
    /* Some Functions
     *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process 
     *    -------------------
 	*    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0
 	*    update step 5: insert proc_struct into hash_list && proc_list, set the relation links of process
     */
+    if ((proc = alloc_proc()) == NULL){
+        goto fork_out;
+    }
+    assert(current->wait_state == 0);
+	proc->parent = current;
+    if ((setup_kstack(proc)) == -E_NO_MEM){
+        goto bad_fork_cleanup_proc;
+    }
+    if (copy_mm(clone_flags, proc) != 0){
+        goto bad_fork_cleanup_kstack;
+    }
+    copy_thread(proc, stack ? stack:proc->kstack + KSTACKSIZE, tf);
+	bool intr_flag;
+	local_intr_save(intr_flag);
+	{
+		proc->pid = get_pid();
+		hash_proc(proc);
+        set_links(proc);
+	}
+	local_intr_restore(intr_flag);
+	wakeup_proc(proc);
+    ret = proc->pid;
 	
 fork_out:
     return ret;
@@ -603,7 +634,7 @@
     //(6) setup trapframe for user environment
     struct trapframe *tf = current->tf;
     memset(tf, 0, sizeof(struct trapframe));
-    /* LAB5:EXERCISE1 YOUR CODE
+    /* LAB5:EXERCISE1 2013012291
      * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags
      * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So
      *          tf_cs should be USER_CS segment (see memlayout.h)
@@ -612,6 +643,11 @@
      *          tf_eip should be the entry point of this binary program (elf->e_entry)
      *          tf_eflags should be set to enable computer to produce Interrupt
      */
+	tf->tf_cs = USER_CS;
+	tf->tf_ss = tf->tf_es = tf->tf_ds = USER_DS;
+	tf->tf_esp = USTACKTOP;
+	tf->tf_eip = elf->e_entry;
+	tf->tf_eflags |= FL_IOPL_MASK + FL_IF;
     ret = 0;
 out:
     return ret;
diff -Nur ../../OSbak/labcodes/lab7/kern/schedule/default_sched.c lab7/kern/schedule/default_sched.c
--- ../../OSbak/labcodes/lab7/kern/schedule/default_sched.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/schedule/default_sched.c	2017-05-09 21:09:38.698461816 +0800
@@ -4,55 +4,156 @@
 #include <assert.h>
 #include <default_sched.h>
 
-static void
-RR_init(struct run_queue *rq) {
-    list_init(&(rq->run_list));
-    rq->proc_num = 0;
+#define USE_SKEW_HEAP 1
+
+/* You should define the BigStride constant here*/
+/* LAB6: YOUR CODE */
+#define BIG_STRIDE    (1 << 20)/* you should give a value, and is ??? */
+
+/* The compare function for two skew_heap_node_t's and the
+ * corresponding procs*/
+static int
+proc_stride_comp_f(void *a, void *b)
+{
+     struct proc_struct *p = le2proc(a, lab6_run_pool);
+     struct proc_struct *q = le2proc(b, lab6_run_pool);
+     int32_t c = p->lab6_stride - q->lab6_stride;
+     if (c > 0) return 1;
+     else if (c == 0) return 0;
+     else return -1;
 }
 
+/*
+ * stride_init initializes the run-queue rq with correct assignment for
+ * member variables, including:
+ *
+ *   - run_list: should be a empty list after initialization.
+ *   - lab6_run_pool: NULL
+ *   - proc_num: 0
+ *   - max_time_slice: no need here, the variable would be assigned by the caller.
+ *
+ * hint: see libs/list.h for routines of the list structures.
+ */
 static void
-RR_enqueue(struct run_queue *rq, struct proc_struct *proc) {
-    assert(list_empty(&(proc->run_link)));
-    list_add_before(&(rq->run_list), &(proc->run_link));
-    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
-        proc->time_slice = rq->max_time_slice;
-    }
-    proc->rq = rq;
-    rq->proc_num ++;
+stride_init(struct run_queue *rq) {
+     /* LAB6: YOUR CODE 
+      * (1) init the ready process list: rq->run_list
+      * (2) init the run pool: rq->lab6_run_pool
+      * (3) set number of process: rq->proc_num to 0       
+      */
+	list_init(&rq->run_list);
+	rq->lab6_run_pool = NULL;
+	rq->proc_num = 0;
 }
 
+/*
+ * stride_enqueue inserts the process ``proc'' into the run-queue
+ * ``rq''. The procedure should verify/initialize the relevant members
+ * of ``proc'', and then put the ``lab6_run_pool'' node into the
+ * queue(since we use priority queue here). The procedure should also
+ * update the meta date in ``rq'' structure.
+ *
+ * proc->time_slice denotes the time slices allocation for the
+ * process, which should set to rq->max_time_slice.
+ * 
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
 static void
-RR_dequeue(struct run_queue *rq, struct proc_struct *proc) {
-    assert(!list_empty(&(proc->run_link)) && proc->rq == rq);
-    list_del_init(&(proc->run_link));
-    rq->proc_num --;
+stride_enqueue(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE 
+      * (1) insert the proc into rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_insert: insert a entry into skew_heap
+      *         list_add_before: insert  a entry into the last of list   
+      * (2) recalculate proc->time_slice
+      * (3) set proc->rq pointer to rq
+      * (4) increase rq->proc_num
+      */
+	rq->lab6_run_pool = skew_heap_insert(rq->lab6_run_pool, 
+						&proc->lab6_run_pool, proc_stride_comp_f);
+	if(0 == proc->time_slice || proc->time_slice < MAX_TIME_SLICE){
+		proc->time_slice = MAX_TIME_SLICE;
+	}
+	proc->rq = rq;
+	rq->proc_num ++;
 }
 
+/*
+ * stride_dequeue removes the process ``proc'' from the run-queue
+ * ``rq'', the operation would be finished by the skew_heap_remove
+ * operations. Remember to update the ``rq'' structure.
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
+static void
+stride_dequeue(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE 
+      * (1) remove the proc from rq correctly
+      * NOTICE: you can use skew_heap or list. Important functions
+      *         skew_heap_remove: remove a entry from skew_heap
+      *         list_del_init: remove a entry from the  list
+      */
+	rq->lab6_run_pool = skew_heap_remove(rq->lab6_run_pool, 
+										 &proc->lab6_run_pool, proc_stride_comp_f);	
+	rq->proc_num --;
+}
+/*
+ * stride_pick_next pick the element from the ``run-queue'', with the
+ * minimum value of stride, and returns the corresponding process
+ * pointer. The process pointer would be calculated by macro le2proc,
+ * see kern/process/proc.h for definition. Return NULL if
+ * there is no process in the queue.
+ *
+ * When one proc structure is selected, remember to update the stride
+ * property of the proc. (stride += BIG_STRIDE / priority)
+ *
+ * hint: see libs/skew_heap.h for routines of the priority
+ * queue structures.
+ */
 static struct proc_struct *
-RR_pick_next(struct run_queue *rq) {
-    list_entry_t *le = list_next(&(rq->run_list));
-    if (le != &(rq->run_list)) {
-        return le2proc(le, run_link);
-    }
-    return NULL;
+stride_pick_next(struct run_queue *rq) {
+     /* LAB6: YOUR CODE 
+      * (1) get a  proc_struct pointer p  with the minimum value of stride
+             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll
+             (1.2) If using list, we have to search list to find the p with minimum stride value
+      * (2) update p;s stride value: p->lab6_stride
+      * (3) return p
+      */
+	if (rq->proc_num == 0){
+		return NULL;
+	}
+	struct proc_struct * p = le2proc(rq->lab6_run_pool, lab6_run_pool);
+	if(p->lab6_priority){
+		p->lab6_stride += BIG_STRIDE / p->lab6_priority;
+	} else {
+		p->lab6_stride += BIG_STRIDE;
+	}
+    return p;
 }
 
+/*
+ * stride_proc_tick works with the tick event of current process. You
+ * should check whether the time slices for current process is
+ * exhausted and update the proc struct ``proc''. proc->time_slice
+ * denotes the time slices left for current
+ * process. proc->need_resched is the flag variable for process
+ * switching.
+ */
 static void
-RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
-    if (proc->time_slice > 0) {
-        proc->time_slice --;
-    }
-    if (proc->time_slice == 0) {
-        proc->need_resched = 1;
-    }
+stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
+     /* LAB6: YOUR CODE */
+	if(--proc->time_slice <= 0){
+		proc->need_resched = 1;
+	}
 }
 
 struct sched_class default_sched_class = {
-    .name = "RR_scheduler",
-    .init = RR_init,
-    .enqueue = RR_enqueue,
-    .dequeue = RR_dequeue,
-    .pick_next = RR_pick_next,
-    .proc_tick = RR_proc_tick,
+     .name = "stride_scheduler",
+     .init = stride_init,
+     .enqueue = stride_enqueue,
+     .dequeue = stride_dequeue,
+     .pick_next = stride_pick_next,
+     .proc_tick = stride_proc_tick,
 };
-
diff -Nur ../../OSbak/labcodes/lab7/kern/schedule/default_sched_stride_c lab7/kern/schedule/default_sched_stride_c
--- ../../OSbak/labcodes/lab7/kern/schedule/default_sched_stride_c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/schedule/default_sched_stride_c	1970-01-01 08:00:00.000000000 +0800
@@ -1,133 +0,0 @@
-#include <defs.h>
-#include <list.h>
-#include <proc.h>
-#include <assert.h>
-#include <default_sched.h>
-
-#define USE_SKEW_HEAP 1
-
-/* You should define the BigStride constant here*/
-/* LAB6: YOUR CODE */
-#define BIG_STRIDE    /* you should give a value, and is ??? */
-
-/* The compare function for two skew_heap_node_t's and the
- * corresponding procs*/
-static int
-proc_stride_comp_f(void *a, void *b)
-{
-     struct proc_struct *p = le2proc(a, lab6_run_pool);
-     struct proc_struct *q = le2proc(b, lab6_run_pool);
-     int32_t c = p->lab6_stride - q->lab6_stride;
-     if (c > 0) return 1;
-     else if (c == 0) return 0;
-     else return -1;
-}
-
-/*
- * stride_init initializes the run-queue rq with correct assignment for
- * member variables, including:
- *
- *   - run_list: should be a empty list after initialization.
- *   - lab6_run_pool: NULL
- *   - proc_num: 0
- *   - max_time_slice: no need here, the variable would be assigned by the caller.
- *
- * hint: see libs/list.h for routines of the list structures.
- */
-static void
-stride_init(struct run_queue *rq) {
-     /* LAB6: YOUR CODE 
-      * (1) init the ready process list: rq->run_list
-      * (2) init the run pool: rq->lab6_run_pool
-      * (3) set number of process: rq->proc_num to 0       
-      */
-}
-
-/*
- * stride_enqueue inserts the process ``proc'' into the run-queue
- * ``rq''. The procedure should verify/initialize the relevant members
- * of ``proc'', and then put the ``lab6_run_pool'' node into the
- * queue(since we use priority queue here). The procedure should also
- * update the meta date in ``rq'' structure.
- *
- * proc->time_slice denotes the time slices allocation for the
- * process, which should set to rq->max_time_slice.
- * 
- * hint: see libs/skew_heap.h for routines of the priority
- * queue structures.
- */
-static void
-stride_enqueue(struct run_queue *rq, struct proc_struct *proc) {
-     /* LAB6: YOUR CODE 
-      * (1) insert the proc into rq correctly
-      * NOTICE: you can use skew_heap or list. Important functions
-      *         skew_heap_insert: insert a entry into skew_heap
-      *         list_add_before: insert  a entry into the last of list   
-      * (2) recalculate proc->time_slice
-      * (3) set proc->rq pointer to rq
-      * (4) increase rq->proc_num
-      */
-}
-
-/*
- * stride_dequeue removes the process ``proc'' from the run-queue
- * ``rq'', the operation would be finished by the skew_heap_remove
- * operations. Remember to update the ``rq'' structure.
- *
- * hint: see libs/skew_heap.h for routines of the priority
- * queue structures.
- */
-static void
-stride_dequeue(struct run_queue *rq, struct proc_struct *proc) {
-     /* LAB6: YOUR CODE 
-      * (1) remove the proc from rq correctly
-      * NOTICE: you can use skew_heap or list. Important functions
-      *         skew_heap_remove: remove a entry from skew_heap
-      *         list_del_init: remove a entry from the  list
-      */
-}
-/*
- * stride_pick_next pick the element from the ``run-queue'', with the
- * minimum value of stride, and returns the corresponding process
- * pointer. The process pointer would be calculated by macro le2proc,
- * see kern/process/proc.h for definition. Return NULL if
- * there is no process in the queue.
- *
- * When one proc structure is selected, remember to update the stride
- * property of the proc. (stride += BIG_STRIDE / priority)
- *
- * hint: see libs/skew_heap.h for routines of the priority
- * queue structures.
- */
-static struct proc_struct *
-stride_pick_next(struct run_queue *rq) {
-     /* LAB6: YOUR CODE 
-      * (1) get a  proc_struct pointer p  with the minimum value of stride
-             (1.1) If using skew_heap, we can use le2proc get the p from rq->lab6_run_poll
-             (1.2) If using list, we have to search list to find the p with minimum stride value
-      * (2) update p;s stride value: p->lab6_stride
-      * (3) return p
-      */
-}
-
-/*
- * stride_proc_tick works with the tick event of current process. You
- * should check whether the time slices for current process is
- * exhausted and update the proc struct ``proc''. proc->time_slice
- * denotes the time slices left for current
- * process. proc->need_resched is the flag variable for process
- * switching.
- */
-static void
-stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
-     /* LAB6: YOUR CODE */
-}
-
-struct sched_class default_sched_class = {
-     .name = "stride_scheduler",
-     .init = stride_init,
-     .enqueue = stride_enqueue,
-     .dequeue = stride_dequeue,
-     .pick_next = stride_pick_next,
-     .proc_tick = stride_proc_tick,
-};
diff -Nur ../../OSbak/labcodes/lab7/kern/schedule/sched.c lab7/kern/schedule/sched.c
--- ../../OSbak/labcodes/lab7/kern/schedule/sched.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/schedule/sched.c	2017-05-08 18:47:26.810399732 +0800
@@ -174,3 +174,8 @@
     }
     local_intr_restore(intr_flag);
 }
+
+void 
+proc_tick(struct proc_struct *proc){
+	sched_class_proc_tick(proc);
+}
diff -Nur ../../OSbak/labcodes/lab7/kern/sync/check_sync.c lab7/kern/sync/check_sync.c
--- ../../OSbak/labcodes/lab7/kern/sync/check_sync.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/sync/check_sync.c	2017-05-10 22:37:49.744133940 +0800
@@ -181,9 +181,14 @@
 void phi_take_forks_condvar(int i) {
      down(&(mtp->mutex));
 //--------into routine in monitor--------------
-     // LAB7 EXERCISE1: YOUR CODE
+     // LAB7 EXERCISE1: 2013012291
      // I am hungry
      // try to get fork
+	 state_condvar[i] = HUNGRY;
+	 phi_test_condvar(i);
+	 if (state_condvar[i] != EATING){
+		cond_wait(&mtp->cv[i]);
+	 }
 //--------leave routine in monitor--------------
       if(mtp->next_count>0)
          up(&(mtp->next));
@@ -195,9 +200,12 @@
      down(&(mtp->mutex));
 
 //--------into routine in monitor--------------
-     // LAB7 EXERCISE1: YOUR CODE
+     // LAB7 EXERCISE1: 2013012291
      // I ate over
      // test left and right neighbors
+	 state_condvar[i]=THINKING; 
+	 phi_test_condvar(LEFT); 
+	 phi_test_condvar(RIGHT); 
 //--------leave routine in monitor--------------
      if(mtp->next_count>0)
         up(&(mtp->next));
diff -Nur ../../OSbak/labcodes/lab7/kern/sync/monitor.c lab7/kern/sync/monitor.c
--- ../../OSbak/labcodes/lab7/kern/sync/monitor.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/sync/monitor.c	2017-05-10 22:37:53.024133265 +0800
@@ -25,7 +25,7 @@
 // Unlock one of threads waiting on the condition variable. 
 void 
 cond_signal (condvar_t *cvp) {
-   //LAB7 EXERCISE1: YOUR CODE
+   //LAB7 EXERCISE1: 2013012291
    cprintf("cond_signal begin: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);  
   /*
    *      cond_signal(cv) {
@@ -37,6 +37,13 @@
    *          }
    *       }
    */
+   if (0 < cvp->count){
+       monitor_t * local_mtp = cvp->owner;
+	   local_mtp->next_count ++;
+	   up(&cvp->sem);
+	   down(&local_mtp->next);
+	   local_mtp->next_count --;
+   }
    cprintf("cond_signal end: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
 }
 
@@ -44,7 +51,7 @@
 // mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor's procedures
 void
 cond_wait (condvar_t *cvp) {
-    //LAB7 EXERCISE1: YOUR CODE
+    //LAB7 EXERCISE1: 2013012291
     cprintf("cond_wait begin:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
    /*
     *         cv.count ++;
@@ -55,5 +62,15 @@
     *         wait(cv.sem);
     *         cv.count --;
     */
+	cvp->count ++;
+	monitor_t * local_mtp = cvp->owner;
+	if (0 < local_mtp->next_count){
+		up(&local_mtp->next);
+	}
+	else{
+		up(&local_mtp->mutex);
+	}
+	down(&cvp->sem);
+	cvp->count --;
     cprintf("cond_wait end:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
 }
diff -Nur ../../OSbak/labcodes/lab7/kern/trap/trap.c lab7/kern/trap/trap.c
--- ../../OSbak/labcodes/lab7/kern/trap/trap.c	2017-02-26 17:12:48.623510657 +0800
+++ lab7/kern/trap/trap.c	2017-05-08 19:02:17.501792755 +0800
@@ -42,7 +42,7 @@
 /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
 void
 idt_init(void) {
-     /* LAB1 YOUR CODE : STEP 2 */
+     /* LAB1 2013012291 : STEP 2 */
      /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
       *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
       *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
@@ -54,9 +54,17 @@
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
-     /* LAB5 YOUR CODE */ 
+     /* LAB5 2013012291 */ 
      //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore
      //so you should setup the syscall interrupt gate in here
+    extern uintptr_t __vectors[];
+    int i;
+    for(i=0;i<256;i++){
+        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
+    } 
+    SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
+    SETGATE(idt[T_SYSCALL], 0, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
+    lidt(&idt_pd);
 }
 
 static const char *
@@ -214,26 +222,33 @@
     LAB3 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages,
     then you can add code here. 
 #endif
-        /* LAB1 YOUR CODE : STEP 3 */
+        /* LAB1 2013012291 : STEP 3 */
         /* handle the timer interrupt */
         /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
          * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
          * (3) Too Simple? Yes, I think so!
          */
-        /* LAB5 YOUR CODE */
+        /* LAB5 2013012291 */
         /* you should upate you lab1 code (just add ONE or TWO lines of code):
          *    Every TICK_NUM cycle, you should set current process's current->need_resched = 1
          */
-        /* LAB6 YOUR CODE */
+        /* LAB6 2013012291 */
         /* you should upate you lab5 code
          * IMPORTANT FUNCTIONS:
 	     * sched_class_proc_tick
          */         
-        /* LAB7 YOUR CODE */
+        /* LAB7 2013012291 */
         /* you should upate you lab6 code
          * IMPORTANT FUNCTIONS:
 	     * run_timer_list
          */
+		ticks++;
+#ifndef DEBUG_GRADE
+        if(0 == ticks%TICK_NUM){
+			print_ticks();
+        }
+#endif
+        run_timer_list();
         break;
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
@@ -242,11 +257,26 @@
     case IRQ_OFFSET + IRQ_KBD:
         c = cons_getc();
         cprintf("kbd [%03d] %c\n", c, c);
+        if ('3' == c){
+            goto t_switch_tou;
+        }
+        if ('0' == c){
+            goto t_switch_tok;
+        }
         break;
-    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    //LAB1 CHALLENGE 1 : 2013012291 you should modify below codes.
     case T_SWITCH_TOU:
+    t_switch_tou:
+        // Switch segment (also ring in cs)
+        tf->tf_cs = USER_CS;
+        tf->tf_ss = tf->tf_es = tf->tf_ds = USER_DS;
+        // enable IO in user ring
+        tf->tf_eflags |= FL_IOPL_MASK;
+        break;
     case T_SWITCH_TOK:
-        panic("T_SWITCH_** ??\n");
+    t_switch_tok:
+        tf->tf_cs = KERNEL_CS;
+        tf->tf_ss = tf->tf_es = tf->tf_ds = KERNEL_DS;
         break;
     case IRQ_OFFSET + IRQ_IDE1:
     case IRQ_OFFSET + IRQ_IDE2:
diff -Nur ../../OSbak/labcodes/lab7/lab7-2013012291.md lab7/lab7-2013012291.md
--- ../../OSbak/labcodes/lab7/lab7-2013012291.md	1970-01-01 08:00:00.000000000 +0800
+++ lab7/lab7-2013012291.md	2017-05-11 13:28:00.874456322 +0800
@@ -0,0 +1,51 @@
+# Lab 7
+
+## Ex1
+
+#### Analysis of Semaphore at Kernel Level 
+- Each semaphore is consist of a value and a waiting queue in which threads on the semaphore sleep.
+    - The waiting queue is basically a doubly linked list with some special parameter checks and APIs such as `wait_queue_first()` which is used for picking the first element (wait_t) of the queue.
+- To initialize a semaphore, set its value according to the parameter, and initialize its waiting queue using `wait_queue_init()`.
+- Two operations on a initialized semaphore, namely `up()` and `down()`, are available. Instructions in these functions will change the semaphore and thus basically within the critical section.
+    - `up()` tries to increase the value in a semaphore, however, if there are threads sleeping on the semaphore, which means the value is "negative", it will wake up one of these threads instead.
+    - `down()` tries to decrease the value in a semaphore, however, if the semaphore is 0, it will make the current thread sleeping on the semaphore and call `schedule()` to yield the control on CPU.
+
+#### How Semaphore Helps to Resolve the Dining Philosophers Problem.
+- Assuming there are N philosophers, 1+N semaphores are necessary to resolve the dining philosophers problem.
+    - The first semaphore is a global mutex, it guarentees at one time, only one philosopher can check or change the status of knives and forks beside him.
+    - The other semaphores are related to the status of philosophers.
+- When a philosopher stops thinking and want to eat, he will first try to check the status of knives and forks beside him. And if there are others doing the same thing, he'll sleep on the mutex semaphore.
+- By doing the check he is actually inspecting the status of philosophers beside him. If they are not eating then it means he can eat, otherwise he'll mark himself as hungry and sleep on his own semaphore.
+- When he finishes eating, he'll check the status of philosophers beside him, if they are hungry (and sleeping because he is eating) and their neighbors aren't eating, he'll wake them up and let them eat.
+
+#### Differences between Semaphores at Kernel Level and User Level.
+- The principles are bacailly the same. However, semaphores at user level should rely on system calls to implement atomic operations.
+
+#### List of Knowledge
+- How ucore implements atomic operation to support synchronization/mutual exclusion (disable interruption).
+- How semaphores are implemented.
+- The idea of a classic synchronization/mutual exclusion problem (dining philosopher).
+
+## Ex2
+
+#### Analysis of Condition Variable at Kernel Level 
+- In principle, condition variables are the same with semaphores, the implementation of condition variables in ucore are based on semaphores.
+    - Apart from a semaphore, a condition variable also contains an integer counting the number of threads waiting on the semaphore and the pointer pointing the owner (a monitor).
+- The monitor managing a group of condition variables contains a global mutex to guarentee at one time only one thread can use the monitor, and a semaphore to pause the monitor itself.
+- The same as semaphores, 2 operations are available for condition variables, which are `cond_signal()` and `cond_wait()`.
+    - If there are threads sleeping on a condition variable, `cond_signal()` will wake up one of the threads and make the current thread sleep on the semaphore `next` , otherwise it'll do nothing.
+    - `cond_wait()` will make a thread sleep on a certain condition variable. It will not yield the mutex immediately if there are threads sleeping on the semaphore `next`.
+
+#### How Condition Variable Helps to Resolve the Dining Philosophers Problem.
+- Basically the same as those in Ex1, a monitor is initialized to help control the status of the philosophers.
+- When a philosopher wish to eating but failed because there are other philosophers biside him eating, it'll sleep on his condition variable using `cond_wait()`.
+- When a philosopher has finished eating, he'll send a signal using `cond_signal()` to sleeping (hungry) philosophers around him who's neighbors are now not eating, so that they'll wake up and begin eating.
+
+#### Differences between Condition Variables at Kernel Level and User Level.
+- The principles are bacailly the same. However, condition variables at user level should rely on system calls to implement atomic operations.
+
+#### Differences from the Answer Provided.
+- Almost the same.
+
+#### List of Knowledge
+- How monitor is implemented and its relationship with semaphores.
Binary files ../../OSbak/labcodes/lab7/lab7.udb and lab7/lab7.udb differ
diff -Nur ../../OSbak/labcodes/lab7/.matrix.log lab7/.matrix.log
--- ../../OSbak/labcodes/lab7/.matrix.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.matrix.log	2017-05-13 08:56:35.268028651 +0800
@@ -0,0 +1,353 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "matrix".
+fork ok.
+pid 13 is running (1000 times)!.
+pid 13 done!.
+pid 15 is running (1100 times)!.
+pid 15 done!.
+pid 17 is running (4600 times)!.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+pid 14 is running (1000 times)!.
+pid 14 done!.
+pid 19 is running (20600 times)!.
+pid 21 is running (2600 times)!.
+pid 23 is running (37100 times)!.
+pid 25 is running (23500 times)!.
+pid 27 is running (23500 times)!.
+pid 16 is running (1900 times)!.
+pid 18 is running (11000 times)!.
+pid 20 is running (37100 times)!.
+pid 29 is running (33400 times)!.
+pid 31 is running (2600 times)!.
+pid 32 is running (26600 times)!.
+pid 22 is running (13100 times)!.
+pid 24 is running (4600 times)!.
+pid 26 is running (2600 times)!.
+pid 28 is running (4600 times)!.
+pid 30 is running (13100 times)!.
+pid 33 is running (13100 times)!.
+pid 26 done!.
+pid 16 done!.
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+pid 31 done!.
+pid 21 done!.
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+pid 17 done!.
+pid 24 done!.
+pid 28 done!.
+Iter 2, No.3 philosopher_sema is thinking
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 1, No.4 philosopher_sema is eating
+Iter 2, No.4 philosopher_sema is thinking
+Iter 2, No.4 philosopher_sema is eating
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+Iter 2, No.4 philosopher_condvar is thinking
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+pid 18 done!.
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+pid 30 done!.
+pid 22 done!.
+Iter 4, No.2 philosopher_sema is thinking
+pid 33 done!.
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+No.0 philosopher_sema quit
+Iter 4, No.4 philosopher_sema is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 3, No.1 philosopher_condvar is thinking
+No.2 philosopher_sema quit
+Iter 2, No.1 philosopher_sema is eating
+Iter 3, No.1 philosopher_sema is thinking
+No.4 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+Iter 3, No.1 philosopher_sema is eating
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.1 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.1 philosopher_sema quit
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+pid 19 done!.
+No.3 philosopher_sema quit
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.4 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+pid 25 done!.
+pid 27 done!.
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+Iter 4, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66b0, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.2 philosopher_condvar is eating
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+pid 32 done!.
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+pid 29 done!.
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+No.4 philosopher_condvar quit
+No.1 philosopher_condvar quit
+pid 23 done!.
+pid 20 done!.
+matrix pass.
+No.3 philosopher_condvar quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.pgdir.log lab7/.pgdir.log
--- ../../OSbak/labcodes/lab7/.pgdir.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.pgdir.log	2017-05-13 08:55:35.304049724 +0800
@@ -0,0 +1,326 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "pgdir".
+I am 2, print pgdir.
+-------------------- BEGIN --------------------
+PDE(001) 00000000-00400000 00400000 urw
+  |-- PTE(00004) 00200000-00204000 00004000 urw
+PDE(001) 00800000-00c00000 00400000 urw
+  |-- PTE(00002) 00800000-00802000 00002000 ur-
+  |-- PTE(00001) 00802000-00803000 00001000 urw
+PDE(001) afc00000-b0000000 00400000 urw
+  |-- PTE(00004) afffc000-b0000000 00004000 urw
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(00001) fac00000-fac01000 00001000 urw
+  |-- PTE(00001) fac02000-fac03000 00001000 urw
+  |-- PTE(00001) faebf000-faec0000 00001000 urw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+pgdir pass.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.priority.log lab7/.priority.log
--- ../../OSbak/labcodes/lab7/.priority.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.priority.log	2017-05-13 08:56:11.996036942 +0800
@@ -0,0 +1,321 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "priority".
+priority process will sleep 400 ticks
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+main: fork ok,now need to wait pids.
+child pid 17, acc 2768000, time 1401
+child pid 15, acc 1672000, time 1401
+child pid 13, acc 588000, time 1401
+main: pid 13, acc 588000, time 1402
+child pid 16, acc 2224000, time 1402
+child pid 14, acc 1132000, time 1402
+main: pid 14, acc 1132000, time 1402
+main: pid 15, acc 1672000, time 1402
+main: pid 16, acc 2224000, time 1402
+main: pid 17, acc 2768000, time 1402
+main: wait pids over
+stride sched correct result: 1 2 3 4 5
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.sleepkill.log lab7/.sleepkill.log
--- ../../OSbak/labcodes/lab7/.sleepkill.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.sleepkill.log	2017-05-13 08:56:26.452031808 +0800
@@ -0,0 +1,308 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "sleepkill".
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+sleepkill pass.
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.sleep.log lab7/.sleep.log
--- ../../OSbak/labcodes/lab7/.sleep.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.sleep.log	2017-05-13 08:56:23.424032887 +0800
@@ -0,0 +1,319 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "sleep".
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+sleep 1 x 100 slices.
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+sleep 2 x 100 slices.
+sleep 3 x 100 slices.
+sleep 4 x 100 slices.
+sleep 5 x 100 slices.
+sleep 6 x 100 slices.
+sleep 7 x 100 slices.
+sleep 8 x 100 slices.
+sleep 9 x 100 slices.
+sleep 10 x 100 slices.
+use 1001 msecs.
+sleep pass.
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.softint.log lab7/.softint.log
--- ../../OSbak/labcodes/lab7/.softint.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.softint.log	2017-05-13 08:55:24.916053279 +0800
@@ -0,0 +1,328 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "softint".
+trapframe at 0xc03affb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc03affd4
+  ebx  0x00000000
+  edx  0x00000000
+  ecx  0xafffffc0
+  eax  0x00000000
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000d General Protection
+  err  0x00000072
+  eip  0x00800f64
+  cs   0x----001b
+  flag 0x00003286 PF,SF,IF,IOPL=3
+  esp  0xafffffa0
+  ss   0x----0023
+unhandled trap.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.spin.log lab7/.spin.log
--- ../../OSbak/labcodes/lab7/.spin.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.spin.log	2017-05-13 08:55:47.416045545 +0800
@@ -0,0 +1,314 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "spin".
+I am the parent. Forking the child...
+I am the parent. Running the child...
+I am the child. spinning ...
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+I am the parent.  Killing the child...
+kill returns 0
+wait returns 0
+spin may pass.
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.testbss.log lab7/.testbss.log
--- ../../OSbak/labcodes/lab7/.testbss.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.testbss.log	2017-05-13 08:55:32.264050769 +0800
@@ -0,0 +1,146 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "testbss".
+Making sure bss works right...
+Yes, good.  Now doing a wild write off the end...
+testbss may pass.
+not valid addr c03020, and  can not find it in vma
+trapframe at 0xc03affb4
+  edi  0x00000000
+  esi  0x00000000
+  ebp  0xafffffa8
+  oesp 0xc03affd4
+  ebx  0x00000000
+  edx  0x008013fa
+  ecx  0xaffffed8
+  eax  0x00000012
+  ds   0x----0023
+  es   0x----0023
+  fs   0x----0000
+  gs   0x----0000
+  trap 0x0000000e Page Fault
+  err  0x00000006
+  eip  0x0080102a
+  cs   0x----001b
+  flag 0x00003286 PF,SF,IF,IOPL=3
+  esp  0xafffff90
+  ss   0x----0023
+killed by kernel.
+kernel panic at kern/trap/trap.c:212:
+    handle user mode pgfault failed. ret=-3
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/tools/grade.sh lab7/tools/grade.sh
--- ../../OSbak/labcodes/lab7/tools/grade.sh	2017-02-26 17:12:48.627510653 +0800
+++ lab7/tools/grade.sh	2017-05-08 18:47:26.842400155 +0800
@@ -290,7 +290,7 @@
         fi
         args="build-$prog $defs"
     fi
-
+    
     build_run "$tag" "$args"
 
     check_result 'check result' "$check" "$@"
diff -Nur ../../OSbak/labcodes/lab7/tools/sign.c lab7/tools/sign.c
--- ../../OSbak/labcodes/lab7/tools/sign.c	2017-02-26 17:12:48.627510653 +0800
+++ lab7/tools/sign.c	2017-05-08 18:47:26.842400155 +0800
@@ -1,3 +1,4 @@
+// Add a signature to the input file (must smaller than 510bytes) to make it legal for MBR
 #include <stdio.h>
 #include <errno.h>
 #include <string.h>
@@ -6,11 +7,15 @@
 int
 main(int argc, char *argv[]) {
     struct stat st;
+	// stat: clib to obtain status of a certain file
+	// the struct contains all kinds of info related to the file, such as size isdir and so on.
     if (argc != 3) {
         fprintf(stderr, "Usage: <input filename> <output filename>\n");
         return -1;
     }
     if (stat(argv[1], &st) != 0) {
+		// stat function : check the status of the first parameter and copy it to the second parameter
+		// if the process is successful, return 0, else return -1
         fprintf(stderr, "Error opening file '%s': %s\n", argv[1], strerror(errno));
         return -1;
     }
diff -Nur ../../OSbak/labcodes/lab7/.waitkill.log lab7/.waitkill.log
--- ../../OSbak/labcodes/lab7/.waitkill.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.waitkill.log	2017-05-13 08:55:50.480044480 +0800
@@ -0,0 +1,314 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "waitkill".
+wait child 1.
+child 2.
+child 1.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+kill parent ok.
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66b0, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.2 philosopher_condvar is eating
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is eating
+kill child1 ok.
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.4 philosopher_condvar quit
+No.1 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab7/.yield.log lab7/.yield.log
--- ../../OSbak/labcodes/lab7/.yield.log	1970-01-01 08:00:00.000000000 +0800
+++ lab7/.yield.log	2017-05-13 08:55:38.332048685 +0800
@@ -0,0 +1,315 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010cc86 (phys)
+  edata  0xc01c1bb4 (phys)
+  end    0xc01c4e64 (phys)
+Kernel executable memory footprint: 788KB
+ebp:0xc0130f48 eip:0xc0100b52 args:0x00010094 0x00010094 0xc0130f78 0xc01000c5 
+    kern/debug/kdebug.c:351: print_stackframe+21
+ebp:0xc0130f58 eip:0xc0100e63 args:0x00000000 0x00000000 0x00000000 0xc0130fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0130f78 eip:0xc01000c5 args:0x00000000 0xc0130fa0 0xffff0000 0xc0130fa4 
+    kern/init/init.c:59: grade_backtrace2+19
+ebp:0xc0130f98 eip:0xc01000e7 args:0x00000000 0xffff0000 0xc0130fc4 0x0000002a 
+    kern/init/init.c:64: grade_backtrace1+27
+ebp:0xc0130fb8 eip:0xc0100104 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:69: grade_backtrace0+19
+ebp:0xc0130fd8 eip:0xc0100125 args:0x00000000 0x00000000 0x00000000 0xc010cca0 
+    kern/init/init.c:74: grade_backtrace+26
+ebp:0xc0130ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:33: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+use SLOB allocator
+kmalloc_init() succeeded!
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+sched class: stride_scheduler
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31799
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 5
+check_swap() succeeded!
+++ setup timer interrupts
+I am No.4 philosopher_condvar
+Iter 1, No.4 philosopher_condvar is thinking
+I am No.3 philosopher_condvar
+Iter 1, No.3 philosopher_condvar is thinking
+I am No.2 philosopher_condvar
+Iter 1, No.2 philosopher_condvar is thinking
+I am No.1 philosopher_condvar
+Iter 1, No.1 philosopher_condvar is thinking
+I am No.0 philosopher_condvar
+Iter 1, No.0 philosopher_condvar is thinking
+I am No.4 philosopher_sema
+Iter 1, No.4 philosopher_sema is thinking
+I am No.3 philosopher_sema
+Iter 1, No.3 philosopher_sema is thinking
+I am No.2 philosopher_sema
+Iter 1, No.2 philosopher_sema is thinking
+I am No.1 philosopher_sema
+Iter 1, No.1 philosopher_sema is thinking
+I am No.0 philosopher_sema
+Iter 1, No.0 philosopher_sema is thinking
+kernel_execve: pid = 2, name = "yield".
+Hello, I am process 2.
+Back in process 2, iteration 0.
+Back in process 2, iteration 1.
+Back in process 2, iteration 2.
+Back in process 2, iteration 3.
+Back in process 2, iteration 4.
+All done in process 2.
+yield pass.
+Iter 1, No.0 philosopher_sema is eating
+Iter 1, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.0 philosopher_condvar is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 1, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.3 philosopher_condvar is eating
+Iter 2, No.2 philosopher_sema is thinking
+Iter 1, No.3 philosopher_sema is eating
+Iter 2, No.0 philosopher_sema is thinking
+Iter 1, No.1 philosopher_sema is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.0 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_condvar is thinking
+Iter 2, No.1 philosopher_sema is thinking
+Iter 2, No.0 philosopher_sema is eating
+Iter 2, No.3 philosopher_sema is thinking
+Iter 2, No.2 philosopher_sema is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 1, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.2 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_sema is thinking
+Iter 2, No.3 philosopher_sema is eating
+Iter 3, No.0 philosopher_sema is thinking
+Iter 2, No.1 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.4 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 2, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_sema is thinking
+Iter 3, No.0 philosopher_sema is eating
+Iter 3, No.3 philosopher_sema is thinking
+Iter 3, No.2 philosopher_sema is eating
+Iter 3, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.2 philosopher_condvar is eating
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.0 philosopher_condvar is thinking
+Iter 4, No.2 philosopher_sema is thinking
+Iter 3, No.3 philosopher_sema is eating
+Iter 4, No.0 philosopher_sema is thinking
+Iter 3, No.1 philosopher_sema is eating
+Iter 3, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 2, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.3 philosopher_condvar is eating
+cond_wait begin:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 1, cvp->owner->next_count 0
+Iter 4, No.1 philosopher_sema is thinking
+Iter 4, No.0 philosopher_sema is eating
+Iter 4, No.3 philosopher_sema is thinking
+Iter 4, No.2 philosopher_sema is eating
+cond_wait end:  cvp c03a6688, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.0 philosopher_condvar is eating
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 3, No.1 philosopher_condvar is thinking
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.3 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[2] will eating
+phi_test_condvar: signal self_cv[2] 
+cond_signal begin: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a66b0, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.2 philosopher_condvar is eating
+No.2 philosopher_sema quit
+Iter 4, No.3 philosopher_sema is eating
+No.0 philosopher_sema quit
+Iter 4, No.1 philosopher_sema is eating
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 3, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.2 philosopher_condvar quit
+No.1 philosopher_sema quit
+No.3 philosopher_sema quit
+Iter 1, No.4 philosopher_sema is eating
+Iter 4, No.1 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[3] will eating
+phi_test_condvar: signal self_cv[3] 
+cond_signal begin: cvp c03a66c4, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66c4, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.3 philosopher_condvar is eating
+cond_signal end: cvp c03a66c4, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.4 philosopher_condvar is thinking
+phi_test_condvar: state_condvar[0] will eating
+phi_test_condvar: signal self_cv[0] 
+cond_signal begin: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+cond_signal end: cvp c03a6688, cvp->count 0, cvp->owner->next_count 0
+Iter 4, No.0 philosopher_condvar is eating
+Iter 2, No.4 philosopher_sema is thinking
+cond_wait begin:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+cond_wait begin:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+No.3 philosopher_condvar quit
+phi_test_condvar: state_condvar[4] will eating
+phi_test_condvar: signal self_cv[4] 
+cond_signal begin: cvp c03a66d8, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a66d8, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.4 philosopher_condvar is eating
+cond_signal end: cvp c03a66d8, cvp->count 0, cvp->owner->next_count 0
+phi_test_condvar: state_condvar[1] will eating
+phi_test_condvar: signal self_cv[1] 
+cond_signal begin: cvp c03a669c, cvp->count 1, cvp->owner->next_count 0
+cond_wait end:  cvp c03a669c, cvp->count 0, cvp->owner->next_count 1
+Iter 4, No.1 philosopher_condvar is eating
+cond_signal end: cvp c03a669c, cvp->count 0, cvp->owner->next_count 0
+No.0 philosopher_condvar quit
+Iter 2, No.4 philosopher_sema is eating
+No.1 philosopher_condvar quit
+No.4 philosopher_condvar quit
+Iter 3, No.4 philosopher_sema is thinking
+Iter 3, No.4 philosopher_sema is eating
+Iter 4, No.4 philosopher_sema is thinking
+Iter 4, No.4 philosopher_sema is eating
+No.4 philosopher_sema quit
+all user-mode processes have quit.
+init check memory pass.
+kernel panic at kern/process/proc.c:468:
+    initproc exit.
+
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
