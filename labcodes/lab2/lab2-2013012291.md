# Lab 2

## Ex0

1. Create patch file from my own version of lab1 code and an original copy of lab1 code using 'diff -Nur ...' command and redirect the output to 'patch.diff'.
2. Apply the patch file to lab2 code using 'patch -d lab2 -p1 < patch.diff'. '-d' means the target is a directory and '-p1' means to ignore the first level of dir.

## Ex1

#### How to implement Fisrt Fit Mem Algorithm?

The framework is already implemented and I only need to modify a few of the codes.
1. In *default_init_memmap*, the flag of each page should be set to correct value.
    - Because all 'reserved'-bits are set to 1 prior to this function, which is to initiallize pages for allocation, those bits should be cleared.
    - On the other hand, because no allocation has actually taken place, all pages are available, which meas the bits for 'property' should be set to 1.
2. In *default_alloc_pages*, the 'property'-bits should be cleared because they are no longer available.
3. In *default_free_pages*, the 'property'-bits should be set because they are available again.
4. Test for 'make qemu' failed. Debugging info shows 

        assert((p0 = alloc_page()) == p2 - 1);

    went wrong. The bug should be fixed.
    - In the implemented FFMA code, the blocks freed is added to the beginning of free_area.
    - So, in the corresponding codes of *default_check*, where p0 is freed first and p1 is freed last, p1 would be at the beginning of the free_area list.
    - Which means when allocating p0 again, p1 is firstly considered, and the position is in p2 + 1 rather than p2 - 1.
    - As *default_check* must not be changed, the logic for FFMA should be adjusted to meet the requirement.
    - My implementation is to change *default_free_pages*. Freed pages is added to the last of the free_area list.

#### How to improve the implemented FFMA?

1. As shown in the video, FFMA should maintain a sorted list according to the address of the pages.
2. To implement this, whenever adding nodes to the list of free pages, always add after the page with the largest address in pages with smaller address than the node to be added. Various algorithm could achieve this goal.
3. If the list was kept sorted, the time complexity for combining free blocks after pages were freed would hopefully be reduced to O(1) rather than O(n). 
4. Besides, if FFMA was implemented this way, the bug in Ex1.4 should not happen.
## Ex2
### Track from BIOS intructions.
- Simply typing in 'make debug' under labcodes/lab1/ dir does not give the desired starting address 0xFFFF0. On the contrary, the starting address is 0x100000, the entrance of kernel rather than bootloader, which does not meet the requirement of the exercise.

- So, qemu and GDB must start manually and stop before bootloader is executed.

- To do this, first, start qemu using 'qemu-system-i386 -hda bin/ucore.img -parallel stdio -s -S'

    The meaning of parameters:<br>
    '-hda bin/ucore.img' means loading bin/ucore.img as the first hard drive.<br>
    'parallel stdio' means redirecting parallel communication to stdio.<br>
    '-s -S' makes qemu stop at the first instruction and wait for GDB command.
    
    Qemu will start in a different window and it's completely blank.

- Then, start GDB in a different terminal using 'GDB obj/bootblock.o'. The parameter helps GDB to find symbols for the bootloader.
- In the GDB interface, establish remote debugging by 'target remote localhost:1234'.

    The connection is successfully established when 'Remote debugging using localhost:1234' shows. Current address is 0xFFFF0, but GDB can not resolve this. Indeed, The command is in BIOS and I have no idea how to show it in GDB.

### Add a break point at 0x7C00 using 'b * 0x7C00'. Then test it.
    
- 'Breakpoint 1 at 0x7C00: file boot/bootasm.S, line 16.' shows, the break point is set successfully.

- Typing 'c' to let the paused program continue. The program will stop at Breakpoint 1, the 16th line of boot/bootasm.S. The command is 'cli' which is to disable interruptions.

- Some messages about the basic info of the system are shown in qemu window. They're probably generated by BIOS.

### Single-step tracking of the code using 'step' and check the differences.

- Typing 'layout asm' and GDB will display all asm instructions of the program. 

    Bootblock.asm, bootasm.S and the disassembly provided by GDB are all slightly different from each other. A major difference is the format of instructions and registers. For example, in bootasm.S, all instuctions are carried out at word level and registers are 16 bits, while in bootblock.asm generated by disassembler, the suffixes of instructions are neglected and the prefixes of the registers are also strange. 

    In most cases, those difference do not matter. What interests me most is 3 cases of %al, (%bx, %si) in the disassembly by GDB at protcseg+17, +22 and +27 respectively. I don't know what's their meanings yet.

### Add customized break point and test it.

- Tried to add a break point at the entrace of a function. Typing in 'break bootmain' and then 'c', The program stopped at 0x7D1E the entrace of bootmain function.

## Ex3

### Why and how to enable A20?

- For backwards compatibility, A20 must be enabled manually to make 4G memory available to CPU.

- The register controling the status of A20 is set by sending command to 8042 MCU. First tell the MCU you wish to write data by sending 0x61, then send 0xDF to set A20 bit.

- Note you have to wait for input buffer not busy to send commands.

### How to initialize GDT?

- GDT is initialized before switching to protected mode by using lgdt command.
    
- The GDT is set to be "blank", which means virtual addresses is identical to physical addresses.

### How to switch to protected mode?

- The protected mode is set by setting certain bit of CR0 register. Fetch CR0 to %eax and manipulate the bits and then send it back and it's done.

## Ex4

### How the bootloader reads sectors of hard disk (HD)?

- First wait for the HD to be ready by checking 0x1F7 port.
- When it's ready, Send 4 bytes to 0x1F3~0x1F6 to inform the HD which sector to read.
- Then instruct the HD to read.
- Wait for HD to be ready again.
- Read the content of the sector from port 0x1F0.

### How the bootloader loads OS in ELF format?

- Read the first page of the OS ELF file as the ELF header.
- Check if it's valid by checking if the first 4 bytes of the file agrees with the ELF magic number.
- Then read the rest of the ELF according to the program headers indicated by ELF header.

## Ex5

### The implementation 

- Get current %ebp and %eip by implemented function.
- Acquire stack info according to %ebp. The previous %ebp is stored at @ebp, the %eip to return is stored at @(ebp+1). 
- And parameters for the stackframe are stored above the %eip one by one.
- Next, to trace back to the previous stackframe, set %ebp and %eip to those stored at @ebp and @(ebp+1)

### The meaning of the last line of output
- %ebp

    Value of %ebp and in the current frame. The base of the stackframe.

- %eip

    The address %eip would jump to after returning from current frame.

- args

    Value of parameters for the currently called function.

- \<unknow\>

    Because when calling the current function the kernel hasn't initialized, there's no stabbing.

    So print_debuginfo() which relies on stabbing does not work and returns unknow.

## Ex6

### Info of IDT

- Each item of IDT consists of 64 bits, aka 8 bytes. 

- The entrance of interruption code is determined by 3 parts of the descriptor. 

    First, the selector at 16bit~31bit determines the segment of the code.

    Second, combining lower bits at 0bit~15bit and higher bits at 48bit~63bit gives the offset from the segment.

### The implementation

- Initialize idt[] using pre-defined macro SETGATE. 

    The parameters, except for 'sel', actually hardly matter at this stage. However, I set my codes the same as those shown in the vedio.

- Add sth in the interruption subroutine (ISR).

    Just print sth.

## Challenge

- Switching rings actually means changing contents of registers. This could be achieved by inline asm, but it's not safe and less modulized.

- A better way is to use interruption, as suggested in the code and lab book.

- In the interruption ISR, change the contents of trapframe and when it's returned, the registers are set according to the ISR.

- There are two ways to change the contents of a trapframe. The first one is to change in the current trapframe directly, and the second one is to build another trapframe and set current %esp to the new trapframe.

    Both ways are applicable. The first way is not safe enough, but it's more efficient for it saves the time of copying. The second way is safer, but it must copy the current trapframe first, which is time and resources consuming.

- To enable keyboard interactive mode switching, check input in the IRQ_KBD ISR. if it's '0' or '3', 'goto' corresponding mode switching ISR.
