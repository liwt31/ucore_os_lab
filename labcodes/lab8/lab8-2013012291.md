# Lab 8

## Ex1

#### Implementation of `sfs_io_nolock()`
- The core of the function is left for us to complete, which is to copy `buf` to the file represented by `sin` or from `sin` to `buf`.  
- Two sets of sub functions, include `sfs_w/rbuf()` and `sfs_w/rblock()` are important for the implementation. 
    - The first ones correspond to IO between buffer and part of a single block, whereas latter ones correspond to IO between buffer and several integrated blocks.
    - The funcions rely on the index of the block in the file rather than in `inode` structures, which could be obtained by `sfs_bmap_load_nolock()`.
- As the start and end position involving IO in the file may not be aligned to blocks, the IO process should be separated to 3 parts, which are:
    1. Rounding the start position to the nearest block and dealing with the margin, if any.
    2. Dealing with the middle of the region comprised of integrated blocks, if any.
    3. Dealing with the "tail" that get neglected because it is smaller than a whole block in the previous step, if any.
- The total amount (Bytes) of data copied should be recorded in `alen` and it should be pass back by using `alenp` pointer.

#### The Design Principle of "PIPE" in UNIX
1. PIPE is used for interprocess communication based on a producer-consumer model. The effect is to make the output of a process to be the input of another process.

#### Differences between Semaphores at Kernel Level and User Level.
- The principles are bacailly the same. However, semaphores at user level should rely on system calls to implement atomic operations.

#### List of Knowledge
- How ucore implements atomic operation to support synchronization/mutual exclusion (disable interruption).
- How semaphores are implemented.
- The idea of a classic synchronization/mutual exclusion problem (dining philosopher).

## Ex2

#### Analysis of Condition Variable at Kernel Level 
- In principle, condition variables are the same with semaphores, the implementation of condition variables in ucore are based on semaphores.
    - Apart from a semaphore, a condition variable also contains an integer counting the number of threads waiting on the semaphore and the pointer pointing the owner (a monitor).
- The monitor managing a group of condition variables contains a global mutex to guarentee at one time only one thread can use the monitor, and a semaphore to pause the monitor itself.
- The same as semaphores, 2 operations are available for condition variables, which are `cond_signal()` and `cond_wait()`.
    - If there are threads sleeping on a condition variable, `cond_signal()` will wake up one of the threads and make the current thread sleep on the semaphore `next` , otherwise it'll do nothing.
    - `cond_wait()` will make a thread sleep on a certain condition variable. It will not yield the mutex immediately if there are threads sleeping on the semaphore `next`.

#### How Condition Variable Helps to Resolve the Dining Philosophers Problem.
- Basically the same as those in Ex1, a monitor is initialized to help control the status of the philosophers.
- When a philosopher wish to eating but failed because there are other philosophers biside him eating, it'll sleep on his condition variable using `cond_wait()`.
- When a philosopher has finished eating, he'll send a signal using `cond_signal()` to sleeping (hungry) philosophers around him who's neighbors are now not eating, so that they'll wake up and begin eating.

#### Differences between Condition Variables at Kernel Level and User Level.
- The principles are bacailly the same. However, condition variables at user level should rely on system calls to implement atomic operations.

#### Differences from the Answer Provided.
- Almost the same.

#### List of Knowledge
- How monitor is implemented and its relationship with semaphores.
