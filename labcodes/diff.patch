diff -Nur ../../OSbak/labcodes/lab3/boot/bootasm.S lab3/boot/bootasm.S
--- ../../OSbak/labcodes/lab3/boot/bootasm.S	2017-02-26 17:12:48.619510661 +0800
+++ lab3/boot/bootasm.S	2017-03-18 17:47:05.900316619 +0800
@@ -26,7 +26,8 @@
     # Enable A20:
     #  For backwards compatibility with the earliest PCs, physical
     #  address line 20 is tied low, so that addresses higher than
-    #  1MB wrap around to zero by default. This code undoes this.
+    #  1MB wrap around to zero by default. This code undoes this
+    #  No need to pay much attention to this code. Take it as a necessary preparation to enable protection mode.
 seta20.1:
     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     testb $0x2, %al
@@ -66,7 +67,9 @@
     # and segment translation that makes virtual addresses
     # identical to physical addresses, so that the
     # effective memory map does not change during the switch.
+    # GDT: global descriptor table.
     lgdt gdtdesc
+	# load gdt, real mode instr
     movl %cr0, %eax
     orl $CR0_PE_ON, %eax
     movl %eax, %cr0
@@ -98,10 +101,16 @@
 # Bootstrap GDT
 .p2align 2                                          # force 4 byte alignment
 gdt:
+	# Fisrt seg descriptor, left blank is requested.
     SEG_NULLASM                                     # null seg
+	# Next 2 segs are for code and data repectively
+	# The first num parameter is the starting address, and the second is the length
+	# they actually overlap and have maximum space
+	# This is for the convenience of education. The protection is weak this way.
     SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
     SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
 
+# Description of gdt
 gdtdesc:
     .word 0x17                                      # sizeof(gdt) - 1
     .long gdt                                       # address gdt
diff -Nur ../../OSbak/labcodes/lab3/boot/bootmain.c lab3/boot/bootmain.c
--- ../../OSbak/labcodes/lab3/boot/bootmain.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/boot/bootmain.c	2017-03-18 17:47:05.900316619 +0800
@@ -37,6 +37,7 @@
 static void
 waitdisk(void) {
     while ((inb(0x1F7) & 0xC0) != 0x40)
+	// inb : assembly language, read(in) a byte(b) from a certain port
         /* do nothing */;
 }
 
@@ -47,10 +48,12 @@
     waitdisk();
 
     outb(0x1F2, 1);                         // count = 1
+	// num of sector to read
     outb(0x1F3, secno & 0xFF);
     outb(0x1F4, (secno >> 8) & 0xFF);
     outb(0x1F5, (secno >> 16) & 0xFF);
     outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+	// 1F3 to 1F6, address of LBA
     outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors
 
     // wait for disk to be ready
@@ -58,6 +61,7 @@
 
     // read a sector
     insl(0x1F0, dst, SECTSIZE / 4);
+	// import double word string from port
 }
 
 /* *
@@ -66,7 +70,8 @@
  * */
 static void
 readseg(uintptr_t va, uint32_t count, uint32_t offset) {
-    uintptr_t end_va = va + count;
+    intptr_t end_va = va + count;
+	// intptr_t : simply another name for int32_t. Why not uint32_t ?
 
     // round down to sector boundary
     va -= offset % SECTSIZE;
@@ -87,9 +92,11 @@
 bootmain(void) {
     // read the 1st page off disk
     readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+	// uintptr_t uint_32.
 
     // is this a valid ELF?
     if (ELFHDR->e_magic != ELF_MAGIC) {
+	// if the reading process goes wrong, the e_magic will not be initialized properly.
         goto bad;
     }
 
diff -Nur ../../OSbak/labcodes/lab3/.check_pmm.log lab3/.check_pmm.log
--- ../../OSbak/labcodes/lab3/.check_pmm.log	1970-01-01 08:00:00.000000000 +0800
+++ lab3/.check_pmm.log	2017-03-18 17:47:05.900316619 +0800
@@ -0,0 +1,57 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc0105be6 (phys)
+  edata  0xc0117a36 (phys)
+  end    0xc0118968 (phys)
+Kernel executable memory footprint: 99KB
+ebp:0xc0116f48 eip:0xc0100a64 args:0x00010094 0x00010094 0xc0116f78 0xc01000ae 
+    kern/debug/kdebug.c:309: print_stackframe+21
+ebp:0xc0116f58 eip:0xc0100d75 args:0x00000000 0x00000000 0x00000000 0xc0116fc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0116f78 eip:0xc01000ae args:0x00000000 0xc0116fa0 0xffff0000 0xc0116fa4 
+    kern/init/init.c:49: grade_backtrace2+19
+ebp:0xc0116f98 eip:0xc01000d0 args:0x00000000 0xffff0000 0xc0116fc4 0x00000029 
+    kern/init/init.c:54: grade_backtrace1+27
+ebp:0xc0116fb8 eip:0xc01000ed args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:59: grade_backtrace0+19
+ebp:0xc0116fd8 eip:0xc010010e args:0x00000000 0x00000000 0x00000000 0xc0105c00 
+    kern/init/init.c:64: grade_backtrace+26
+ebp:0xc0116ff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:29: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+c01b9000
+check_pgdir() succeeded!
+0
+1ba007
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+++ setup timer interrupts
+0: @ring 0
+0:  cs = 8
+0:  ds = 10
+0:  es = 10
+0:  ss = 10
++++ switch to  user  mode +++
+100 ticks
+End of Test.
+kernel panic at kern/trap/trap.c:18:
+    EOT: kernel seems ok.
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab3/.check_swap.log lab3/.check_swap.log
--- ../../OSbak/labcodes/lab3/.check_swap.log	1970-01-01 08:00:00.000000000 +0800
+++ lab3/.check_swap.log	2017-03-26 20:59:42.152018476 +0800
@@ -0,0 +1,98 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc0108565 (phys)
+  edata  0xc0120a60 (phys)
+  end    0xc0121b5c (phys)
+Kernel executable memory footprint: 135KB
+ebp:0xc011ff48 eip:0xc0100a6e args:0x00010094 0x00010094 0xc011ff78 0xc01000b8 
+    kern/debug/kdebug.c:309: print_stackframe+21
+ebp:0xc011ff58 eip:0xc0100d7f args:0x00000000 0x00000000 0x00000000 0xc011ffc8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc011ff78 eip:0xc01000b8 args:0x00000000 0xc011ffa0 0xffff0000 0xc011ffa4 
+    kern/init/init.c:58: grade_backtrace2+19
+ebp:0xc011ff98 eip:0xc01000da args:0x00000000 0xffff0000 0xc011ffc4 0x0000002a 
+    kern/init/init.c:63: grade_backtrace1+27
+ebp:0xc011ffb8 eip:0xc01000f7 args:0x00000000 0xc010002a 0xffff0000 0xc010006d 
+    kern/init/init.c:68: grade_backtrace0+19
+ebp:0xc011ffd8 eip:0xc0100118 args:0x00000000 0x00000000 0x00000000 0xc0108580 
+    kern/init/init.c:73: grade_backtrace+26
+ebp:0xc011fff8 eip:0xc010007a args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:32: kern_init+79
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+check_vma_struct() succeeded!
+page fault at 0x00000100: K/W [no page found].
+check_pgfault() succeeded!
+check_vmm() succeeded.
+ide 0:      10000(sectors), 'QEMU HARDDISK'.
+ide 1:     262144(sectors), 'QEMU HARDDISK'.
+SWAP: manager = fifo swap manager
+BEGIN check_swap: count 1, total 31965
+setup Page Table for vaddr 0X1000, so alloc a page
+setup Page Table vaddr 0~4MB OVER!
+set up init env for check_swap begin!
+page fault at 0x00001000: K/W [no page found].
+page fault at 0x00002000: K/W [no page found].
+page fault at 0x00003000: K/W [no page found].
+page fault at 0x00004000: K/W [no page found].
+set up init env for check_swap over!
+write Virt Page c in fifo_check_swap
+write Virt Page a in fifo_check_swap
+write Virt Page d in fifo_check_swap
+write Virt Page b in fifo_check_swap
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+write Virt Page b in fifo_check_swap
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+write Virt Page b in fifo_check_swap
+page fault at 0x00002000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
+swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
+write Virt Page c in fifo_check_swap
+page fault at 0x00003000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
+swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
+write Virt Page d in fifo_check_swap
+page fault at 0x00004000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
+swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
+write Virt Page e in fifo_check_swap
+page fault at 0x00005000: K/W [no page found].
+swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
+swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
+write Virt Page a in fifo_check_swap
+page fault at 0x00001000: K/R [no page found].
+swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
+swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
+count is 0, total is 7
+check_swap() succeeded!
+++ setup timer interrupts
+100 ticks
+End of Test.
+kernel panic at kern/trap/trap.c:20:
+    EOT: kernel seems ok.
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -Nur ../../OSbak/labcodes/lab3/kern/debug/kdebug.c lab3/kern/debug/kdebug.c
--- ../../OSbak/labcodes/lab3/kern/debug/kdebug.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/debug/kdebug.c	2017-03-18 17:47:05.900316619 +0800
@@ -293,7 +293,7 @@
  * */
 void
 print_stackframe(void) {
-     /* LAB1 YOUR CODE : STEP 1 */
+     /* LAB1 2013012291 : STEP 1 */
      /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
       * (2) call read_eip() to get the value of eip. the type is (uint32_t);
       * (3) from 0 .. STACKFRAME_DEPTH
@@ -305,5 +305,21 @@
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
+    uint32_t ebp = read_ebp();
+    uint32_t eip = read_eip();
+    int i;
+    for(i=0;i<STACKFRAME_DEPTH;i++){
+        if(0 == ebp) break;
+        cprintf("ebp:0x%08x eip:0x%08x ", ebp, eip);
+        cprintf("args:");
+        int j;
+        for(j=0;j<4;j++){
+            cprintf("0x%08x ",*((uint32_t*)ebp+2+j));
+        }
+        cprintf("\n");
+        print_debuginfo(eip-1);
+        eip = *((uint32_t*)ebp + 1);
+        ebp = *((uint32_t*)ebp);
+    }
 }
 
diff -Nur ../../OSbak/labcodes/lab3/kern/init/init.c lab3/kern/init/init.c
--- ../../OSbak/labcodes/lab3/kern/init/init.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/init/init.c	2017-03-20 20:34:34.513782298 +0800
@@ -47,6 +47,7 @@
     //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
     // user/kernel mode switch test
     //lab1_switch_test();
+    // commented when doing lab3. Introduce protection fault
 
     /* do nothing */
     while (1);
@@ -93,11 +94,28 @@
 static void
 lab1_switch_to_user(void) {
     //LAB1 CHALLENGE 1 : TODO
+    // Make room for esp and ss
+    asm volatile ( "subl $8, %%esp \n"
+            "int %0 \n"
+    // restore esp from pushl ebp;movl esp,ebp
+            "movl %%ebp, %%esp"
+             : 
+             : "i" (T_SWITCH_TOU));
 }
 
 static void
 lab1_switch_to_kernel(void) {
     //LAB1 CHALLENGE 1 :  TODO
+    // It is commented in trapframe that the last 2 bytes of struct trapframe
+    // is reserved for crossing rings. As far as I am concerned, switching from
+    // user to kernel is crossing ring. So I left 2 bytes here just in case. If 
+    // it's not necessary it doesn't matter, because in the end it's what's 
+    // stores in %ebp that determines the value of %esp
+    asm volatile ( "subl $8, %%esp \n"
+            "int %0 \n"
+            "movl %%ebp, %%esp"
+             : 
+             : "i" (T_SWITCH_TOK));
 }
 
 static void
diff -Nur ../../OSbak/labcodes/lab3/kern/mm/default_pmm.c lab3/kern/mm/default_pmm.c
--- ../../OSbak/labcodes/lab3/kern/mm/default_pmm.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/mm/default_pmm.c	2017-03-18 17:47:05.900316619 +0800
@@ -9,7 +9,7 @@
    usually split, and the remainder added to the list as another free block.
    Please see Page 196~198, Section 8.2 of Yan Wei Min's chinese book "Data Structure -- C programming language"
 */
-// LAB2 EXERCISE 1: YOUR CODE
+// LAB2 EXERCISE 1: 2013012291
 // you should rewrite functions: default_init,default_init_memmap,default_alloc_pages, default_free_pages.
 /*
  * Details of FFMA
@@ -72,10 +72,10 @@
     for (; p != base + n; p ++) {
         assert(PageReserved(p));
         p->flags = p->property = 0;
+        SetPageProperty(p);
         set_page_ref(p, 0);
     }
     base->property = n;
-    SetPageProperty(base);
     nr_free += n;
     list_add(&free_list, &(base->page_link));
 }
@@ -97,13 +97,17 @@
     }
     if (page != NULL) {
         list_del(&(page->page_link));
-        if (page->property > n) {
+        if (page->property > n) { // If the block is not malloced completely, 
+                                    // create a new block
             struct Page *p = page + n;
             p->property = page->property - n;
             list_add(&free_list, &(p->page_link));
-    }
+        }
+        struct Page *p = page;
+        for(; p != page + n; p ++){
+            ClearPageProperty(p);
+        }
         nr_free -= n;
-        ClearPageProperty(page);
     }
     return page;
 }
@@ -115,10 +119,10 @@
     for (; p != base + n; p ++) {
         assert(!PageReserved(p) && !PageProperty(p));
         p->flags = 0;
+        SetPageProperty(p);
         set_page_ref(p, 0);
     }
     base->property = n;
-    SetPageProperty(base);
     list_entry_t *le = list_next(&free_list);
     while (le != &free_list) {
         p = le2page(le, page_link);
@@ -136,7 +140,7 @@
         }
     }
     nr_free += n;
-    list_add(&free_list, &(base->page_link));
+    list_add_before(&free_list, &(base->page_link));
 }
 
 static size_t
diff -Nur ../../OSbak/labcodes/lab3/kern/mm/memlayout.h lab3/kern/mm/memlayout.h
--- ../../OSbak/labcodes/lab3/kern/mm/memlayout.h	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/mm/memlayout.h	2017-03-18 17:47:05.900316619 +0800
@@ -123,7 +123,7 @@
 
 /* free_area_t - maintains a doubly linked list to record free (unused) pages */
 typedef struct {
-    list_entry_t free_list;         // the list header
+    list_entry_t free_list;         // the list header, actually acts as a sentinel
     unsigned int nr_free;           // # of free pages in this free list
 } free_area_t;
 
diff -Nur ../../OSbak/labcodes/lab3/kern/mm/pmm.c lab3/kern/mm/pmm.c
--- ../../OSbak/labcodes/lab3/kern/mm/pmm.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/mm/pmm.c	2017-03-18 22:08:00.511593628 +0800
@@ -360,7 +360,7 @@
 // return vaule: the kernel virtual address of this pte
 pte_t *
 get_pte(pde_t *pgdir, uintptr_t la, bool create) {
-    /* LAB2 EXERCISE 2: YOUR CODE
+    /* LAB2 EXERCISE 2: 2013012291
      *
      * If you need to visit a physical address, please use KADDR()
      * please read pmm.h for useful macros
@@ -393,6 +393,21 @@
     }
     return NULL;          // (8) return page table entry
 #endif
+    pde_t *pdep = pgdir + PDX(la);
+    if (!(*pdep & PTE_P)){
+        if (!create){
+            return NULL;
+        }
+        struct Page *page_p = alloc_page();
+        if (!page_p){
+            return NULL;
+        }
+        set_page_ref(page_p, 1);
+        uintptr_t ptp = page2pa(page_p);
+        memset(KADDR(ptp), 0, PGSIZE);
+        *pdep = (uint32_t)ptp + PTE_USER;
+    }
+    return KADDR(PDE_ADDR(*pdep) + 4 * PTX(la)); // use a constant to mimic pointer operation
 }
 
 //get_page - get related Page struct for linear address la using PDT pgdir
@@ -413,7 +428,7 @@
 //note: PT is changed, so the TLB need to be invalidate 
 static inline void
 page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
-    /* LAB2 EXERCISE 3: YOUR CODE
+    /* LAB2 EXERCISE 3: 2013012291
      *
      * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
      *
@@ -438,6 +453,14 @@
                                   //(6) flush tlb
     }
 #endif
+    if (*ptep & PTE_P){
+        struct Page *page_p = pte2page(*ptep);
+        if (page_ref_dec(page_p) == 0){
+            free_page(page_p);
+        }
+        *ptep = 0;
+        tlb_invalidate(pgdir, la);
+    }
 }
 
 //page_remove - free an Page which is related linear address la and has an validated pte
diff -Nur ../../OSbak/labcodes/lab3/kern/mm/swap.c lab3/kern/mm/swap.c
--- ../../OSbak/labcodes/lab3/kern/mm/swap.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/mm/swap.c	2017-03-26 20:59:33.148081343 +0800
@@ -123,7 +123,7 @@
      assert(result!=NULL);
 
      pte_t *ptep = get_pte(mm->pgdir, addr, 0);
-     // cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
+     //cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
     
      int r;
      if ((r = swapfs_read((*ptep), result)) != 0)
diff -Nur ../../OSbak/labcodes/lab3/kern/mm/swap_fifo.c lab3/kern/mm/swap_fifo.c
--- ../../OSbak/labcodes/lab3/kern/mm/swap_fifo.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/mm/swap_fifo.c	2017-03-26 20:58:31.200580812 +0800
@@ -38,6 +38,21 @@
      //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
      return 0;
 }
+static void
+print_list(list_entry_t * head){
+    if ( head == NULL){
+        extern struct mm_struct *check_mm_struct;
+        head=(list_entry_t*) check_mm_struct->sm_priv;
+    }
+    cprintf("head---> %x\n", head);
+    cprintf("head->prev---> %x\n", head->prev);
+    list_entry_t *cur = head->next;
+    while(cur != head){
+        struct Page * page = le2page(cur, pra_page_link);
+        cprintf("%x - %x - %x\n", cur, page, page->pra_vaddr);
+        cur = cur->next;
+    }
+}
 /*
  * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
  */
@@ -51,6 +66,7 @@
     //record the page access situlation
     /*LAB3 EXERCISE 2: YOUR CODE*/ 
     //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+    list_add_before(head, entry);
     return 0;
 }
 /*
@@ -67,14 +83,28 @@
      /*LAB3 EXERCISE 2: YOUR CODE*/ 
      //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
      //(2)  set the addr of addr of this page to ptr_page
+     *ptr_page = le2page(head->next, pra_page_link);
+     list_del(head->next);
      return 0;
 }
 
+
+static void
+diag(int avoid){
+    print_list(NULL);
+    int i;
+    for (i = 0; i < 5 ; i++){
+        if (i == avoid) continue;
+        cprintf("%x, ", *(unsigned char *)((1 + i) * 0x1000));
+    }
+}
+
 static int
 _fifo_check_swap(void) {
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num==4);
+    assert(check_mm_struct != NULL);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num==4);
@@ -84,29 +114,38 @@
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num==4);
+    //diag(5);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num==5);
+   // diag(0);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num==5);
+    //diag(0);
     cprintf("write Virt Page a in fifo_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num==6);
+    //diag(1);
     cprintf("write Virt Page b in fifo_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num==7);
+    //diag(2);
     cprintf("write Virt Page c in fifo_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num==8);
+    //diag(3);
     cprintf("write Virt Page d in fifo_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
     assert(pgfault_num==9);
+    //diag(4);
     cprintf("write Virt Page e in fifo_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num==10);
+    //diag(1);
     cprintf("write Virt Page a in fifo_check_swap\n");
     assert(*(unsigned char *)0x1000 == 0x0a);
+    //diag(1);
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num==11);
     return 0;
diff -Nur ../../OSbak/labcodes/lab3/kern/mm/vmm.c lab3/kern/mm/vmm.c
--- ../../OSbak/labcodes/lab3/kern/mm/vmm.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/mm/vmm.c	2017-03-27 22:23:24.793710183 +0800
@@ -346,8 +346,7 @@
 
     ret = -E_NO_MEM;
 
-    pte_t *ptep=NULL;
-    /*LAB3 EXERCISE 1: YOUR CODE
+    /*LAB3 EXERCISE 1: 2013012291
     * Maybe you want help comment, BELOW comments can help you finish the code
     *
     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
@@ -364,15 +363,20 @@
     *   mm->pgdir : the PDT of these vma
     *
     */
-#if 0
-    /*LAB3 EXERCISE 1: YOUR CODE*/
-    ptep = ???              //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+    /*LAB3 EXERCISE 1: 2013012291*/
+    pte_t *ptep = get_pte(mm->pgdir, addr, 1);              //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+    if (ptep == NULL){
+        cprintf("Get pte for addr 0x%08x failed.\n", addr);
+        goto failed;
+    }
     if (*ptep == 0) {
-                            //(2) if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr
-
+        if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL){
+            cprintf("Alloc page for 0x%08x failed.\n", addr);
+            goto failed;
+        }
     }
     else {
-    /*LAB3 EXERCISE 2: YOUR CODE
+    /*LAB3 EXERCISE 2: 2013012291
     * Now we think this pte is a  swap entry, we should load data from disk to a page with phy addr,
     * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page.
     *
@@ -383,19 +387,28 @@
     *    page_insert ： build the map of phy addr of an Page with the linear addr la
     *    swap_map_swappable ： set the page swappable
     */
+        //(1）According to the mm AND addr, try to load the content of right disk page
+        //    into the memory which page managed.
+        //(2) According to the mm, addr AND page, setup the map of phy addr <---> logical addr
+        //(3) make the page swappable.
         if(swap_init_ok) {
             struct Page *page=NULL;
-                                    //(1）According to the mm AND addr, try to load the content of right disk page
-                                    //    into the memory which page managed.
-                                    //(2) According to the mm, addr AND page, setup the map of phy addr <---> logical addr
-                                    //(3) make the page swappable.
+            swap_in(mm, addr, &page);
+            if (page != NULL) {
+                if (page_insert(mm->pgdir, page, addr, perm) != 0) {
+                    free_page(page);
+                    cprintf("Insert page 0x%08x to pte failed.\n");
+                    goto failed;
+                }
+                swap_map_swappable(mm, addr, page, 0);
+                page->pra_vaddr = addr;
+            }
         }
         else {
             cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
             goto failed;
         }
    }
-#endif
    ret = 0;
 failed:
     return ret;
diff -Nur ../../OSbak/labcodes/lab3/kern/trap/trap.c lab3/kern/trap/trap.c
--- ../../OSbak/labcodes/lab3/kern/trap/trap.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/kern/trap/trap.c	2017-03-26 20:59:39.484036862 +0800
@@ -36,7 +36,7 @@
 /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
 void
 idt_init(void) {
-     /* LAB1 YOUR CODE : STEP 2 */
+     /* LAB1 2013012291 : STEP 2 */
      /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
       *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
       *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
@@ -48,6 +48,13 @@
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
+    extern uintptr_t __vectors[];
+    int i;
+    for(i=0;i<256;i++){
+        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
+    } 
+    SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
+    lidt(&idt_pd);
 }
 
 static const char *
@@ -180,12 +187,16 @@
     LAB3 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages, 
     then you can add code here. 
 #endif
-        /* LAB1 YOUR CODE : STEP 3 */
+        /* LAB1 2013012291 : STEP 3 */
         /* handle the timer interrupt */
         /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
          * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
          * (3) Too Simple? Yes, I think so!
          */
+        ticks++;
+        if(0 == ticks%TICK_NUM){
+            print_ticks();
+        }
         break;
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
@@ -194,11 +205,26 @@
     case IRQ_OFFSET + IRQ_KBD:
         c = cons_getc();
         cprintf("kbd [%03d] %c\n", c, c);
+        if ('3' == c){
+            goto t_switch_tou;
+        }
+        if ('0' == c){
+            goto t_switch_tok;
+        }
         break;
-    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    //LAB1 CHALLENGE 1 : 2013012291 you should modify below codes.
     case T_SWITCH_TOU:
+    t_switch_tou:
+        // Switch segment (also ring in cs)
+        tf->tf_cs = USER_CS;
+        tf->tf_ss = tf->tf_es = tf->tf_ds = USER_DS;
+        // enable IO in user ring
+        tf->tf_eflags |= FL_IOPL_MASK;
+        break;
     case T_SWITCH_TOK:
-        panic("T_SWITCH_** ??\n");
+    t_switch_tok:
+        tf->tf_cs = KERNEL_CS;
+        tf->tf_ss = tf->tf_es = tf->tf_ds = KERNEL_DS;
         break;
     case IRQ_OFFSET + IRQ_IDE1:
     case IRQ_OFFSET + IRQ_IDE2:
diff -Nur ../../OSbak/labcodes/lab3/lab3-2013012291.md lab3/lab3-2013012291.md
--- ../../OSbak/labcodes/lab3/lab3-2013012291.md	1970-01-01 08:00:00.000000000 +0800
+++ lab3/lab3-2013012291.md	2017-03-28 07:44:29.086339772 +0800
@@ -0,0 +1,92 @@
+# Lab 3
+
+## Ex1
+
+#### Map physical pages for virtural address.
+
+1. Find the pte for the virtual address. If the pte does not exist, create one by setting the thrid parameter of *get_pte* to 1.
+2. Check the return of system call *get_pte*. If it returns NULL, go to "failed".
+3. Check the value of the returned page table entry.
+    - If it is newly created, i.e. the value equals to 0. It means the page entry as well as the page does not exist previously, an initialization of the page is requested.
+    - If it is not newly created, i.e. the value does not equal to 0. It means the page has been swapped out of the memory. Then it needs to be swapped back, which is the purpose of Ex2.
+3. Assuming the page entry is newly created, alloc a page for the address using *pgdir_alloc_page*, the parameter "perm" is defined prior in thie function.
+    1. *pgdir_alloc_page* will first alloc a page then initialize it according to its parameters.  
+    2. First the page should be connected to the page table by *page_insert* in *pmm.c*. This will map the page and set the permission bits in page table entry.
+    3. Then the page should be added to the list of swappable pages and record the virturl linear address in its pra_vaddr member variable, which is essential to the functionality of swap system.
+
+#### Meanings of components in page table directory and page table entries.
+- High 20 bits: the base address for next level of memory management module, which could be page table or page. These info are essensial for CPU to construct physical address from virtual address.
+- Low 12 bits: flags recording properties of the entry, including whether it presents, is writable, is changed and so on. The definations are in mmu.h. With these flags, ucore and CPU would be able to:
+    - manage page table and cache page entry more effectively.
+        - 2 bits particularly useful for page replacement algorithm are "accessed bit" and "dirty bit". The spirit of clock like algorithms is to check these bits and find the page that is not used recently.
+    - protect data from being accessed or written in a potentially hazardous manner.
+
+#### If an exception happens while accessing a page, what would hardware do next?
+1. Protect the context, such as values of %eip and %cs.
+2. Pass the control to the kernel, which would carry out corresponding (page fault) ISR.
+3. If the exception happends when carrying out ISR, goto **1.**. This might cause an infinite loop, until stack overflow.
+
+#### Difference with the answer provided.
+- Forgot to check return value for system call *pgidr_alloc_page*. Corrected now.
+
+#### List of knowledge.
+- Different conditions for a page fault.
+- Privilege control from vma_struct and page table entry.
+
+## Ex2
+
+#### Implementation of FIFO PRA.
+
+- Three parts of the code need to be implemented. The first two parts are in *swap_fifo.c*. And the last part is in *vmm.c*.
+- Code in *swap_fifo.c* concerns manipulation of linked list. The code will decide which page to be switched out when a page fault occurs, based on a FIFO PRA.
+    - The list is used as queue and new element is added before the head (sentinel) while the oldest element is deleted right after the head.
+    - *_fifo_swap_out_victim* effectively returns 2 values. The first reports the status of the function by direct "return". And the second is the address of the page to be swapped out by "*ptr_page = ...;". A pointer is used to pass more than 1 return value.
+- Code in *vmm.c* concerns how to swap in the requested page stored in disks. 
+    1. Check if the swap system is initialized properly.
+    2. Swap in the page calling *swap_in*. The page allocated for the swapped page is returned using a pointer. If there's not enough space in memory, another page should be swaped out.
+    2. The logic of the rest part of the code is the same with those in *pgdir_alloc_page*, so I simply copied that piece of code into this function.
+        - The job *pgdir_alloc_page* does has already been analyzed in **Ex1 -> Map physical pages for virtual address. -> 3.**. 
+        - The main difference between code in *pgdir_allc_page* and my copy is that in *pgdir_alloc_page* the page is allocated by *pgdir_alloc_page* while in my code the page is swapped in from disks.
+        - I also deleted some redundant codes, such as checking if swap system is initialized.
+
+#### Design of extended clock PRA.
+- See **Challenge**.
+- The page to be swaped out should not be accessed or wrote recently, which could be judged by their accessed bit or dirty bit in pte. If they are both 0, then the page is suitable to be swapped out.
+- Swap in when the page is accessed. Swap out when there's not enough space in memory.
+
+#### Difference with the answer provided.
+- Bascially the same. Mine does return value check for *page_insert* while the answer doesn't. The answer set the return value of *do_pgfualt* as return value of *swap_in* while mine doesn't.
+
+#### List of knowledge.
+- The right time to swap in and out pages.
+- Manipulation of double linked list. Queue. Use pointer to pass more than one return values.
+- Establishment of the relation between virtual address and physical address, especially recording virtual address in Page structure, which is not mentioned in delivered lectures.
+
+## Challenge
+
+#### Implementation of extended clock PRA.
+
+##### Overview.
+- My code is in directory lab3_clock. The directory is copied from a completed version of lab3, and I changed below listed files.
+- In *mmu.h*, macros controlling pte, or more specifically, reading and clearing accessed bit and dirty bit are implemented. 
+- In *swap.c*, when initializing swap manager, set *swap_manager_clock* as the manager.
+- Create *swap_clock.c/h* and implement the *swap_manager_clock*. Delete redundant *swap_fifo.c/h*.
+
+##### Details of the implementation.
+1. Decalre a global static variable *clock_arm*, which is a list_entry_t pointer, acting as the arm in the clock. In *_clock_init_mm* it is initialized to be the head of the page list.
+2. When choosing victim page, find the first one whose accessed bit and dirty bit are 0.
+    1. First move the arm to the next position in the clock. If it points to the head, skip the position and enter the next cycle.
+    2. Find the pte of the virtual address requested according to *pra_vaddr* in the Page structure recording the virtual address mapped to the page.
+    3. Consider accessed bit and dirty bit of ptes in swap manager and find the right one to be swapped out. 
+        - It should be taken into account that CPU would preferably change the accessed bit and dirty bit in the pte in TLB (if exists) rather than the pte in memory accessable by OS.
+        - So calling *tlb_invalidate* to invalidate the pte in TLB before evaluation of the bits is necessary. This would sync the content, aka accessed bit and dirty bit of pte between TLB and memory.
+        - If one of bits is 1, i.e. the page is visited or written recently, clear it, move to next position and start agagin.
+        - If both of accessed bit and dirty bit are 0, then the page is suitable to be swaped out, record it and set the clock arm to the previous position of this page.
+3. When adding new page to the list in *_clock_map_swappable*, firstly add it after the arm of the clock, then set the arm to it.
+    - In this way, the newly added page would be the last to visit when the arm is running around a clock circle starting from this position. This would make new pages stay in the list longer.
+4. I also implemented *diag* and *print_list* for debugging.
+
+##### Test cases.
+- Test cases are designed and implemented in *_clock_check_swap*. The details of the test could be found in the comments in the function.
+- Enable printing list in *diag* and the debugging output will be in great agreement with theoretical prediction in the comments mentioned above.
+- The test cases are basically the same with those in *_fifo_chekc_swap*, however, the number of page faults is significantly decreased. This demonstrates the effeciency of clock PRA.
diff -Nur ../../OSbak/labcodes/lab3/tools/sign.c lab3/tools/sign.c
--- ../../OSbak/labcodes/lab3/tools/sign.c	2017-02-26 17:12:48.619510661 +0800
+++ lab3/tools/sign.c	2017-03-18 17:47:05.900316619 +0800
@@ -1,3 +1,4 @@
+// Add a signature to the input file (must smaller than 510bytes) to make it legal for MBR
 #include <stdio.h>
 #include <errno.h>
 #include <string.h>
@@ -6,11 +7,15 @@
 int
 main(int argc, char *argv[]) {
     struct stat st;
+	// stat: clib to obtain status of a certain file
+	// the struct contains all kinds of info related to the file, such as size isdir and so on.
     if (argc != 3) {
         fprintf(stderr, "Usage: <input filename> <output filename>\n");
         return -1;
     }
     if (stat(argv[1], &st) != 0) {
+		// stat function : check the status of the first parameter and copy it to the second parameter
+		// if the process is successful, return 0, else return -1
         fprintf(stderr, "Error opening file '%s': %s\n", argv[1], strerror(errno));
         return -1;
     }
